/*
 * Copyright (c) 2012-2026, QORE Lab, Imperial College London
 * All rights reserved.
 */

package jline.solvers.fluid.handlers;

import static jline.GlobalConstants.Inf;

import jline.lang.Network;
import jline.lang.NetworkStruct;
import jline.GlobalConstants;
import jline.lang.constant.SolverType;
import jline.solvers.NetworkAvgTable;
import jline.solvers.SolverOptions;
import jline.solvers.fluid.SolverFluid;
import jline.solvers.ssa.SolverSSA;
import jline.util.matrix.Matrix;
import jline.util.matrix.MatrixEquation;
import org.apache.commons.math3.optim.*;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.math3.random.JDKRandomGenerator;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.util.FastMath;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.lang.Double.isInfinite;

// NOTE TO USER: this class has been developed for research and experimentation purposes only.
// Currently, a user is required to manually edit the local variables contained within some of this
// class' methods to change the functionality of the search-based p-norm smoothing methodology -
// this is sufficient for research and experimentation, but not for general release. Should this
// methodology be made available as part of a JLINE release in the future, a small amount of
// refactoring will be needed to move local variables to class fields, paying due attention to
// encapsulation and the flexibility required by a typical user. This is left as the subject of
// future work, given this methodology remains in the research and experimentation phase at the
// close of this current project.

public class PStarSearcher {
    // TODO: this still needs integration with the fluid solver as per info above
    public long runTime;

    private void determinePStarInitialSolution(
            double[] pStarInitialSolution,
            Network model,
            Matrix sumXQa,
            Matrix SQa,
            double threshold) {

        SolverFluid solver = new SolverFluid(model);
        NetworkStruct sn = solver.sn;
        int M = sn.nstations;
        int K = sn.nclasses;
        Matrix nPhases = sn.phases;

        int idx = 0;
        for (int i = 0; i < M; i++) {
            double xVal = sumXQa.get(idx, 0);
            double cVal = SQa.get(idx, 0);
            // 100.0 used as an arbitrarily large number - any larger risks errors due to use as an exponent
            double maximumGHatValue = 1.0 / FastMath.pow(1 + FastMath.pow(xVal / cVal, 100.0), 1 / 100.0);
            double j = 0.1;
            while (true) {
                double gHatValue = 1 / FastMath.pow(1 + FastMath.pow(xVal / cVal, j), 1 / j);
                if (gHatValue >= threshold * maximumGHatValue) {
                    pStarInitialSolution[i] = j / 2;
                    break;
                }
                j += 0.1;
            }
            idx += K * nPhases.get(i, 0);
        }
    }

    private void determineSigmaInitialValues(double[] sigmaInitialValues, double[] pStarInitialSolution) {

        for (int i = 0; i < pStarInitialSolution.length; i++) {
            sigmaInitialValues[i] = pStarInitialSolution[i] / 2;
        }
    }

    // Runs the CMA-ES algorithm to find pStar
    public PointValuePair findPStarValues(Network model, Matrix targetQueueLengths) {

        // Construct parameters for CMA-ES Optimisation
        int numNodes = model.getNumberOfNodes();
        double[] pStarInitialSolution = new double[numNodes];
        double[] sigmaInitialValues = new double[numNodes];
        double[] pStarLowerBound = new double[numNodes];
        double[] pStarUpperValue = new double[numNodes];
        // pStar is bounded between Distribution.zeroRN and +INF
        for (int i = 0; i < numNodes; i++) {
            pStarLowerBound[i] = GlobalConstants.Zero;
            pStarUpperValue[i] = Inf;
        }

        //// USER INPUT ////: Manually set arguments for CMA-ES Optimisation
        // Some comments and usage instructions taken from:
        // https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.html

        // Maximal number of iterations for CMA-ES optimizer
        int maxIterations = 100;

        // Optimizer stops if the objective function's output (errorValue) is less than stopFitness.
        // Taking a single node, the error is the square of the difference between the steady-state mean
        // queue-length generated by Fluid versus the same generated by SSA.
        // errorValue is the sum of these squared differences across all nodes.
        double stopFitnessTol = 0.01; // e.g. 0.01 means 1% of the total jobs are allocated incorrectly
        int numJobs = (int) model.getNumberOfJobs().elementSum();
        double stopFitness = FastMath.pow(stopFitnessTol * numJobs, 2) * 2;

        // Chooses the covariance matrix update method for CMA-ES optimizer
        boolean isActiveCMA = true;

        // Number of initial iterations where the covariance matrix remains diagonal
        int diagonalOnly = 0;

        // Random Generator - configurable to other Apache Commons RNGs if desired
        RandomGenerator rng = new JDKRandomGenerator();

        // Determines how often new random objective variables are generated in case they are out of
        // bounds
        int checkFeasibleCount = 0;

        // Determines whether statistic data is collected (or not)
        boolean generateStatistics = false;

        // Convergence checker - thresholds can be specified
        ConvergenceChecker<PointValuePair> checker = new SimpleValueChecker(0.001, 0.001);

        // Set the maximum number of evaluations of the function to be optimized
        // Can set lower using " = new MaxEval(int);"
        MaxEval maxEval = MaxEval.unlimited();

        // Set the population size. The number of offspring is the primary strategy parameter. In the
        // absence of better clues, a good default could be an integer close to 4 + 3 ln(n), where n is
        // the number of optimized parameters. Increasing the population size improves global search
        // properties at the expense of speed (which in general decreases at most linearly with
        // increasing population size).
        int defaultSize = (int) FastMath.round(4 + 3 * FastMath.log(pStarInitialSolution.length));
        CMAESOptimizer.PopulationSize populationSize = new CMAESOptimizer.PopulationSize(defaultSize);

        // Fill pStarInitialSolution[]
        // The only parameter to specify here is percentageToComputePStarUpperValue - the methodology
        // used is specified in Section 6.2 of the report accompanying this repository
        double percentageToComputePStarUpperValue = 0.999;
        Map<String, Matrix> gHatInputs = getGHatInputs(model, targetQueueLengths);
        determinePStarInitialSolution(
                pStarInitialSolution,
                model,
                gHatInputs.get("sumXQa"),
                gHatInputs.get("SQa"),
                percentageToComputePStarUpperValue);

        //

        // Determine sigmaInitialValues automatically
        // Sigma values define the initial coordinate-wise standard deviations for sampling
        // new search points around pStarInitialSolution. It is suggested to set them to the estimated
        // distance from the initial to the desired optimum. Small values induce the search to be more
        // local (and very small values are more likely to find a local optimum close to the initial
        // guess). Too small values might however lead to early termination.
        // Determine best guesses automatically
        determineSigmaInitialValues(sigmaInitialValues, pStarInitialSolution);

        // Run the CMA-ES optimisation process
        CMAESOptimizer optimizer =
                new CMAESOptimizer(
                        maxIterations,
                        stopFitness,
                        isActiveCMA,
                        diagonalOnly,
                        checkFeasibleCount,
                        rng,
                        generateStatistics,
                        checker);

        CMAESObjectiveFunction CMAESObjectiveFunction =
                new CMAESObjectiveFunction(targetQueueLengths, model, false);

        long startTime = System.nanoTime();
        PointValuePair output =
                optimizer.optimize(
                        maxEval,
                        new ObjectiveFunction(CMAESObjectiveFunction),
                        GoalType.MINIMIZE,
                        new InitialGuess(pStarInitialSolution),
                        populationSize,
                        new CMAESOptimizer.Sigma(sigmaInitialValues),
                        new SimpleBounds(pStarLowerBound, pStarUpperValue));
        this.runTime = System.nanoTime() - startTime;

        return output;
    }

    // Generates the target (accurate) queue lengths used within the CMA-ES objective function
    public Matrix generateTargetQueueLengths(Network model) {

        //// USER INPUT ////: Manually set options for SolverSSA
        int numSamplesSSA = 5000;
        int seedSSA = 50;
        //int R5kSSA = 19;

        // Model solved using SolverSSA
        SolverOptions options = new SolverOptions(SolverType.SSA);
        options.samples = numSamplesSSA;
        options.seed = seedSSA;
        SolverSSA solverSSA = new SolverSSA(model, options);
        //solverSSA.enableR5(R5kSSA);
        NetworkAvgTable avgTable = solverSSA.getAvgTable();
        List<Double> QueueLengths = avgTable.getQLen();

        // Note that if SolverSSA cannot be used due to the existence of bugs, comparison queue lengths
        // need to be manually added using e.g. SolverMVA in LINE
        // List<Double> QueueLengths = new ArrayList<>();
        // QueueLengths.add(0, 12.905);
        // QueueLengths.add(1, 17.083);
//
//    // Mean Queue Length transferred to a JLineMatrix
        Matrix QNSSA = new Matrix(model.getNumberOfNodes(), model.getNumberOfClasses());
        int numRows = QNSSA.getNumRows();
        for (int row = 0; row < numRows; row++) {
            int numCols = QNSSA.getNumCols();
            for (int col = 0; col < numCols; col++) {
                QNSSA.set(row, col, QueueLengths.get((row * numCols) + col));
            }
        }

        return QNSSA;
    }

    // Returns the variables needed to compute the smoothed processor-share constraint approximation
    // for a given model. This is subsequently used to derive sensible values for
    // pStarInitialSolution[], as per Section 6.2 in the report that accompanies this repository
    private Map<String, Matrix> getGHatInputs(Network model, Matrix targetQueueLengths) {

        SolverFluid solver = new SolverFluid(model);
        NetworkStruct sn = solver.sn;
        SolverOptions options = solver.options;
        options.stiff = false;
        options.method = "matrix";

        if (options.init_sol.isEmpty()) {
            solver.initSol();
        }

        // N.B. Method assumes no prior probabilities - it will break if it encounters this

        int M = sn.nstations;
        int K = sn.nclasses;
        int totalNumPhases = (int) sn.phases.elementSum();

        Matrix S = sn.nservers.copy();
        double initialPopulation = sn.njobs.elementSum();
        int SRows = S.getNumRows();
        for (int i = 0; i < SRows; i++) {
            if (isInfinite(S.get(i, 0))) {
                S.set(i, 0, initialPopulation);
            }
        }


        Matrix Qa = new Matrix(1, totalNumPhases);
        int state = 0;
        for (int i = 0; i < M; i++) {
            for (int r = 0; r < K; r++) {
                int nPhases = (int) sn.phases.get(i, r);
                for (int k = 0; k < nPhases; k++) {
                    Qa.set(0, state, i);
                    state++;
                }
            }
        }

        Matrix SQ = new Matrix(totalNumPhases, totalNumPhases);
        int nextSQRow = 0;
        for (int i = 0; i < M; i++) {
            for (int r = 0; r < K; r++) {
                int nPhases = (int) sn.phases.get(i, r);
                for (int k = 0; k < nPhases; k++) {
                    for (int col = 0; col < totalNumPhases; col++) {
                        if (Qa.get(0, col) == i) {
                            SQ.set(nextSQRow, col, 1); // Setting weights
                        }
                    }
                    nextSQRow++;
                }
            }
        }

        Matrix x = new Matrix(totalNumPhases, 1);
        int end = 0;
        for (int i = 0; i < M; i++) {
            for (int r = 0; r < K; r++) {
                int numPhases = (int) sn.phases.get(i, r);
                for (int k = 0; k < numPhases; k++) {
                    x.set(end, 0, targetQueueLengths.get(i, r) / numPhases);
                    end++;
                }
            }
        }

        Matrix SQa = new Matrix(Qa.getNumCols(), 1);
        for (int i = 0; i < totalNumPhases; i++) {
            SQa.set(i, 0, S.get((int) Qa.get(0, i), 0));
        }

        MatrixEquation calculateSumXQa = new MatrixEquation();
        calculateSumXQa.alias(x, "x", SQ, "SQ", GlobalConstants.Zero, "distribZero");
        calculateSumXQa.process("sumXQa = distribZero + SQ * x");
        Matrix sumXQa = calculateSumXQa.lookupSimple("sumXQa");

        Map<String, Matrix> outputs = new HashMap<>();
        outputs.put("sumXQa", sumXQa);
        outputs.put("SQa", SQa);
        return outputs;
    }
}
