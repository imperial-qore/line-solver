/*
 * Copyright (c) 2012-2026, QORE Lab, Imperial College London
 * All rights reserved.
 */

package jline.io.tikz;

import jline.lang.JobClass;
import jline.lang.Network;
import jline.lang.NetworkStruct;
import jline.lang.nodes.Node;
import jline.util.matrix.Matrix;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Exports a queueing network model as a TikZ diagram.
 * Can generate LaTeX code, compile to PDF, and display the result.
 */
public class TikZExporter {

    private final Network model;
    private final TikZOptions options;
    private final TikZNodeRenderer renderer;
    private final TikZLayoutEngine layoutEngine;

    /**
     * Creates a TikZ exporter with default options.
     */
    public TikZExporter(Network model) {
        this(model, new TikZOptions());
    }

    /**
     * Creates a TikZ exporter with custom options.
     */
    public TikZExporter(Network model, TikZOptions options) {
        this.model = model;
        this.options = options;
        this.renderer = new TikZNodeRenderer(options);
        this.layoutEngine = new TikZLayoutEngine(model, options);
    }

    /**
     * Generates TikZ code for the network.
     *
     * @return Complete LaTeX document with TikZ diagram
     */
    public String generateTikZ() {
        // Compute layout
        layoutEngine.computeLayout();
        Map<Node, double[]> positions = layoutEngine.getAllPositions();

        StringBuilder sb = new StringBuilder();

        // Preamble with styles
        sb.append(renderer.getPreamble());
        sb.append("\n");

        // Document body
        sb.append("\\begin{document}\n");
        sb.append("\\begin{tikzpicture}\n");
        sb.append("\n");

        List<Node> allNodes = model.getNodes();

        // Filter nodes if hiding auto-generated ones
        List<Node> visibleNodes = filterVisibleNodes(allNodes);

        // Build connection map for collapsed edges when hiding auto-generated nodes
        Map<Node, Set<Node>> collapsedConnections = buildCollapsedConnections(allNodes, visibleNodes);

        // Render visible nodes
        sb.append("% Nodes\n");
        for (Node node : visibleNodes) {
            double[] pos = positions.get(node);
            if (pos != null) {
                sb.append(renderer.renderNode(node, pos[0], pos[1]));
            }
        }
        sb.append("\n");

        // Render connections with edge routing to avoid overlaps
        sb.append("% Connections\n");
        NetworkStruct sn = model.getStruct();
        if (sn != null && sn.connmatrix != null) {
            Map<JobClass, Map<JobClass, Matrix>> rtorig = sn.rtorig;

            // Create edge router with visible node positions only
            Map<Node, double[]> visiblePositions = new java.util.HashMap<Node, double[]>();
            for (Node node : visibleNodes) {
                visiblePositions.put(node, positions.get(node));
            }
            TikZEdgeRouter edgeRouter = new TikZEdgeRouter(visiblePositions, options);

            // Use collapsed connections if hiding auto-generated nodes
            for (Node from : visibleNodes) {
                Set<Node> targets = collapsedConnections.get(from);
                if (targets != null) {
                    for (Node to : targets) {
                        String fromId = sanitizeId(from.getName());
                        String toId = sanitizeId(to.getName());

                        // Handle self-loops specially
                        if (edgeRouter.isSelfLoop(from, to)) {
                            sb.append(renderSelfLoop(fromId, from, Double.NaN));
                        } else {
                            // Compute waypoints to avoid node overlaps
                            java.util.List<double[]> waypoints = edgeRouter.computeWaypoints(from, to, visibleNodes);

                            String fromAnchor = getOutputAnchor(from);
                            String toAnchor = getInputAnchor(to);

                            // Render routed edge
                            sb.append(TikZEdgeRouter.renderRoutedEdge(
                                    fromId, toId, fromAnchor, toAnchor, waypoints, Double.NaN, options));
                        }
                    }
                }
            }
        }

        sb.append("\n");
        sb.append("\\end{tikzpicture}\n");
        sb.append("\\end{document}\n");

        return sb.toString();
    }

    /**
     * Filters the list of nodes to only include visible ones.
     * If hideAutoGeneratedNodes is true, filters out auto-generated ClassSwitch nodes.
     */
    private List<Node> filterVisibleNodes(List<Node> allNodes) {
        if (!options.isHideAutoGeneratedNodes()) {
            return allNodes;
        }

        List<Node> visible = new java.util.ArrayList<Node>();
        for (Node node : allNodes) {
            if (!isAutoGeneratedNode(node)) {
                visible.add(node);
            }
        }
        return visible;
    }

    /**
     * Checks if a node is auto-generated (like ClassSwitch nodes for class-switching routing).
     */
    private boolean isAutoGeneratedNode(Node node) {
        if (node instanceof jline.lang.nodes.ClassSwitch) {
            // ClassSwitch nodes with names like "CS_X_to_Y" are auto-generated
            String name = node.getName();
            return name.startsWith("CS_") && name.contains("_to_");
        }
        return false;
    }

    /**
     * Builds a map of collapsed connections, tracing paths through auto-generated nodes
     * to find the real source and destination nodes.
     */
    private Map<Node, Set<Node>> buildCollapsedConnections(List<Node> allNodes, List<Node> visibleNodes) {
        Map<Node, Set<Node>> result = new java.util.HashMap<Node, Set<Node>>();
        for (Node node : visibleNodes) {
            result.put(node, new java.util.HashSet<Node>());
        }

        NetworkStruct sn = model.getStruct();
        if (sn == null || sn.connmatrix == null) {
            return result;
        }

        Matrix connMatrix = sn.connmatrix;
        int n = allNodes.size();
        Set<Node> visibleSet = new java.util.HashSet<Node>(visibleNodes);

        // Build adjacency lists
        Map<Node, List<Node>> successors = new java.util.HashMap<Node, List<Node>>();
        for (int i = 0; i < n; i++) {
            Node from = allNodes.get(i);
            successors.put(from, new java.util.ArrayList<Node>());
            for (int j = 0; j < n; j++) {
                if (connMatrix.get(i, j) > 0) {
                    successors.get(from).add(allNodes.get(j));
                }
            }
        }

        // For each visible node, find all reachable visible nodes
        // going through auto-generated nodes
        for (Node from : visibleNodes) {
            Set<Node> visited = new java.util.HashSet<Node>();
            java.util.Queue<Node> queue = new java.util.LinkedList<Node>();

            // Start from successors of this node
            for (Node succ : successors.get(from)) {
                if (!visited.contains(succ)) {
                    queue.add(succ);
                    visited.add(succ);
                }
            }

            while (!queue.isEmpty()) {
                Node current = queue.poll();

                if (visibleSet.contains(current)) {
                    // Found a visible node - add connection
                    result.get(from).add(current);
                } else {
                    // Auto-generated node - continue through it
                    for (Node succ : successors.get(current)) {
                        if (!visited.contains(succ)) {
                            queue.add(succ);
                            visited.add(succ);
                        }
                    }
                }
            }
        }

        return result;
    }

    /**
     * Renders a self-loop edge using four linear segments for a clean rectangular path.
     * The loop exits from the server, goes up, left, down, and right to the buffer's left side.
     */
    private String renderSelfLoop(String nodeId, Node node, double prob) {
        StringBuilder sb = new StringBuilder();

        // For queues with servers, create a four-segment orthogonal self-loop:
        // 1. Exit from server's north, go up vertically
        // 2. Go left horizontally (above the node)
        // 3. Go down vertically (to the level of buffer.west)
        // 4. Go right horizontally to the buffer's west side
        if (node instanceof jline.lang.nodes.Queue && options.isShowServerCount()) {
            // Four-segment orthogonal loop with explicit waypoints
            // Server is ~0.6cm wide, buffer is ~1.1cm wide
            // Loop goes: up 0.6, left 1.8 (past buffer), down 0.6, right to buffer.west
            sb.append(String.format("\\draw[conn] (%s_server.north) -- ++(0,0.6) -- ++(-1.8,0) -- ++(0,-0.6) -- (%s.west);\n",
                    nodeId, nodeId));
        } else {
            // For non-queue nodes, use four-segment orthogonal loop on the left side
            sb.append(String.format("\\draw[conn] (%s.north) -- ++(0,0.5) -- ++(-0.8,0) -- ++(0,-0.5) -- (%s.west);\n",
                    nodeId, nodeId));
        }

        return sb.toString();
    }

    /**
     * Gets the routing probability from node i to node j.
     * Returns NaN if not available.
     */
    private double getRoutingProbability(Map<JobClass, Map<JobClass, Matrix>> rtorig, int i, int j) {
        if (rtorig == null || rtorig.isEmpty()) {
            return Double.NaN;
        }

        // Sum probabilities across all classes
        double totalProb = 0;
        int classCount = 0;

        for (Map.Entry<JobClass, Map<JobClass, Matrix>> entry : rtorig.entrySet()) {
            Map<JobClass, Matrix> innerMap = entry.getValue();
            if (innerMap != null) {
                for (Matrix rtMatrix : innerMap.values()) {
                    if (rtMatrix != null && i < rtMatrix.getNumRows() && j < rtMatrix.getNumCols()) {
                        double p = rtMatrix.get(i, j);
                        if (!Double.isNaN(p) && p > 0) {
                            totalProb += p;
                            classCount++;
                        }
                    }
                }
            }
        }

        return classCount > 0 ? totalProb / classCount : Double.NaN;
    }

    /**
     * Counts the out-degree of a node.
     */
    private int countOutDegree(Matrix connMatrix, int i, int n) {
        int count = 0;
        for (int j = 0; j < n; j++) {
            if (connMatrix.get(i, j) > 0) {
                count++;
            }
        }
        return count;
    }

    /**
     * Gets the index of an edge among all edges from the same source.
     */
    private int getEdgeIndex(Matrix connMatrix, int i, int targetJ, int n) {
        int index = 0;
        for (int j = 0; j < targetJ; j++) {
            if (connMatrix.get(i, j) > 0) {
                index++;
            }
        }
        return index;
    }

    /**
     * Computes the bend angle for a curved edge.
     */
    private double computeBendAngle(int outDegree, int edgeIndex) {
        if (outDegree <= 1) {
            return 0;
        }
        // Distribute edges evenly, centered around 0
        double step = 30.0;  // degrees between edges
        double offset = (outDegree - 1) * step / 2.0;
        return edgeIndex * step - offset;
    }

    /**
     * Exports the TikZ code to a file.
     *
     * @param filePath Path to the output .tex file
     */
    public void exportToFile(String filePath) throws IOException {
        String tikzCode = generateTikZ();
        Path path = new File(filePath).toPath();
        Files.write(path, tikzCode.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Exports the network diagram to a PNG file.
     * Requires pdflatex and pdftoppm (from poppler-utils) to be installed.
     *
     * @param filePath Path to the output .png file
     * @param dpi Resolution in dots per inch (default 150)
     * @throws IOException If file operations fail
     * @throws RuntimeException If conversion fails
     */
    public void exportToPNG(String filePath, int dpi) throws IOException {
        // First generate PDF
        File pdfFile = exportToPDF();

        // Convert PDF to PNG using pdftoppm
        String pngPathWithoutExt = filePath.replaceAll("\\.png$", "");
        ProcessBuilder pb = new ProcessBuilder(
                "pdftoppm",
                "-png",
                "-r", String.valueOf(dpi),
                "-singlefile",
                pdfFile.getAbsolutePath(),
                pngPathWithoutExt
        );
        pb.redirectErrorStream(true);

        Process process = pb.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        StringBuilder output = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            output.append(line).append("\n");
        }

        try {
            int exitCode = process.waitFor();
            if (exitCode != 0) {
                throw new RuntimeException("pdftoppm conversion failed:\n" + output.toString());
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("pdftoppm was interrupted", e);
        }
    }

    /**
     * Exports the network diagram to a PNG file with default 150 DPI.
     *
     * @param filePath Path to the output .png file
     */
    public void exportToPNG(String filePath) throws IOException {
        exportToPNG(filePath, 150);
    }

    /**
     * Compiles the TikZ code to PDF using pdflatex.
     *
     * @return The generated PDF file
     * @throws IOException          If file operations fail
     * @throws RuntimeException     If pdflatex fails
     */
    public File exportToPDF() throws IOException {
        if (!isPdfLatexAvailable()) {
            throw new RuntimeException("pdflatex is not available. Please install TeX Live or MiKTeX.");
        }

        // Create temporary directory
        Path tempDir = Files.createTempDirectory("line-tikz-");
        Path texFile = tempDir.resolve("network.tex");
        Path pdfFile = tempDir.resolve("network.pdf");

        // Write .tex file
        String tikzCode = generateTikZ();
        Files.write(texFile, tikzCode.getBytes(StandardCharsets.UTF_8));

        // Compile with pdflatex
        ProcessBuilder pb = new ProcessBuilder(
                "pdflatex",
                "-interaction=nonstopmode",
                "-output-directory=" + tempDir.toString(),
                texFile.toString()
        );
        pb.redirectErrorStream(true);
        pb.directory(tempDir.toFile());

        Process process = pb.start();

        // Read output
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        StringBuilder output = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            output.append(line).append("\n");
        }

        try {
            int exitCode = process.waitFor();
            if (exitCode != 0 || !Files.exists(pdfFile)) {
                throw new RuntimeException("pdflatex compilation failed:\n" + output.toString());
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("pdflatex was interrupted", e);
        }

        return pdfFile.toFile();
    }

    /**
     * Displays the network diagram.
     * Compiles to PDF and opens in the system viewer.
     */
    public void display() {
        if (!isPdfLatexAvailable()) {
            // Fallback: save .tex file and inform user
            String texPath = "network-diagram.tex";
            try {
                exportToFile(texPath);
                System.out.println("pdflatex not found. TikZ code saved to: " + texPath);
                System.out.println("Compile manually with: pdflatex " + texPath);
            } catch (IOException e) {
                System.err.println("Failed to save TikZ file: " + e.getMessage());
            }
            return;
        }

        try {
            File pdf = exportToPDF();
            TikZViewer.displayPDF(pdf, model.getName());
        } catch (Exception e) {
            System.err.println("Failed to generate visualization: " + e.getMessage());
            // Try to save .tex as fallback
            try {
                String texPath = "network-diagram.tex";
                exportToFile(texPath);
                System.out.println("TikZ code saved to: " + texPath);
            } catch (IOException ex) {
                System.err.println("Failed to save TikZ file: " + ex.getMessage());
            }
        }
    }

    /**
     * Checks if pdflatex is available on the system.
     */
    public static boolean isPdfLatexAvailable() {
        try {
            ProcessBuilder pb = new ProcessBuilder("pdflatex", "--version");
            pb.redirectErrorStream(true);
            Process p = pb.start();
            int exitCode = p.waitFor();
            return exitCode == 0;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Gets the options used by this exporter.
     */
    public TikZOptions getOptions() {
        return options;
    }

    /**
     * Sanitizes a node name to be a valid TikZ identifier.
     */
    private String sanitizeId(String name) {
        return name.replaceAll("[^a-zA-Z0-9]", "_");
    }

    /**
     * Gets the output anchor point for a node.
     */
    private String getOutputAnchor(Node node) {
        // Check Delay first since it extends Queue but renders differently
        if (node instanceof jline.lang.nodes.Delay) {
            // Delay nodes are ellipses, connect from east
            return ".east";
        }
        if (node instanceof jline.lang.nodes.Queue) {
            // Queues have a server box, connect from server's east
            return "_server.east";
        }
        return ".east";
    }

    /**
     * Gets the input anchor point for a node.
     */
    private String getInputAnchor(Node node) {
        return ".west";
    }

    /**
     * Generates TikZ code for a combined network + Markov chain diagram.
     * The Markov chain represents the environment states.
     *
     * @param stageNames Names of the environment stages
     * @param transitionRates Matrix of transition rates between stages
     * @return TikZ code for the Markov chain placed to the right of the network
     */
    public String generateEnvironmentTikZ(String[] stageNames, double[][] transitionRates) {
        // Compute layout for network
        layoutEngine.computeLayout();
        Map<Node, double[]> positions = layoutEngine.getAllPositions();

        StringBuilder sb = new StringBuilder();

        // Preamble with styles
        sb.append(renderer.getPreamble());
        sb.append("\n");

        // Document body
        sb.append("\\begin{document}\n");
        sb.append("\\begin{tikzpicture}[scale=1.1]\n");  // Scale QN figure 10% larger
        sb.append("\n");

        List<Node> allNodes = model.getNodes();
        List<Node> visibleNodes = filterVisibleNodes(allNodes);
        Map<Node, Set<Node>> collapsedConnections = buildCollapsedConnections(allNodes, visibleNodes);

        // Render network nodes
        sb.append("% Queueing Network\n");
        for (Node node : visibleNodes) {
            double[] pos = positions.get(node);
            if (pos != null) {
                sb.append(renderer.renderNode(node, pos[0], pos[1]));
            }
        }
        sb.append("\n");

        // Render network connections
        sb.append("% Network Connections\n");
        NetworkStruct sn = model.getStruct();
        if (sn != null && sn.connmatrix != null) {
            Map<Node, double[]> visiblePositions = new java.util.HashMap<Node, double[]>();
            for (Node node : visibleNodes) {
                visiblePositions.put(node, positions.get(node));
            }
            TikZEdgeRouter edgeRouter = new TikZEdgeRouter(visiblePositions, options);

            for (Node from : visibleNodes) {
                Set<Node> targets = collapsedConnections.get(from);
                if (targets != null) {
                    for (Node to : targets) {
                        String fromId = sanitizeId(from.getName());
                        String toId = sanitizeId(to.getName());

                        if (edgeRouter.isSelfLoop(from, to)) {
                            sb.append(renderSelfLoop(fromId, from, Double.NaN));
                        } else {
                            java.util.List<double[]> waypoints = edgeRouter.computeWaypoints(from, to, visibleNodes);
                            String fromAnchor = getOutputAnchor(from);
                            String toAnchor = getInputAnchor(to);
                            sb.append(TikZEdgeRouter.renderRoutedEdge(fromId, toId, fromAnchor, toAnchor, waypoints, Double.NaN, options));
                        }
                    }
                }
            }
        }
        sb.append("\n");

        // Calculate position for Markov chain (to the right of the network)
        // Note: positions are already scaled by 1.1 due to tikzpicture scale
        double maxX = Double.MIN_VALUE;
        double minY = Double.MAX_VALUE;
        double maxY = Double.MIN_VALUE;
        for (double[] pos : positions.values()) {
            maxX = Math.max(maxX, pos[0]);
            minY = Math.min(minY, pos[1]);
            maxY = Math.max(maxY, pos[1]);
        }

        double mcX = maxX + 6.0;  // Place Markov chain to the right

        // Render Markov chain
        sb.append("% Environment Markov Chain\n");
        int numStages = stageNames.length;

        // Match CTMC vertical height with network height
        double networkHeight = maxY - minY;
        double stageSpacing = numStages > 1 ? networkHeight / (numStages - 1) : 0;
        if (stageSpacing < 1.5) {
            stageSpacing = 1.5;  // Minimum spacing for readability
        }
        double centerY = (minY + maxY) / 2.0;

        // Render state nodes (30% smaller: 1.2cm * 0.7 = 0.84cm)
        for (int i = 0; i < numStages; i++) {
            double y = centerY + (numStages - 1 - 2 * i) * stageSpacing / 2.0;
            sb.append(String.format("\\node[draw,circle,minimum size=0.84cm,fill=blue!10] (mc_%d) at (%.2f,%.2f) {%s};\n",
                    i, mcX, y, stageNames[i]));
        }
        sb.append("\n");

        // Render transitions as separate, clearly visible edges
        sb.append("% Environment Transitions\n");
        for (int i = 0; i < numStages; i++) {
            for (int j = 0; j < numStages; j++) {
                if (i != j && transitionRates[i][j] > 0) {
                    // Use different bend directions with larger angles to ensure visible separation
                    String bendDir = i < j ? "bend left" : "bend right";
                    // Use 50 degree bend for better visibility of overlapping edges
                    sb.append(String.format("\\draw[conn] (mc_%d) to[%s=50] node[midway,fill=white,font=\\footnotesize] {%.1f} (mc_%d);\n",
                            i, bendDir, transitionRates[i][j], j));
                }
            }
        }

        sb.append("\n");
        sb.append("\\end{tikzpicture}\n");
        sb.append("\\end{document}\n");

        return sb.toString();
    }

    /**
     * Exports a combined network + Markov chain diagram to PNG.
     */
    public void exportEnvironmentToPNG(String filePath, int dpi, String[] stageNames, double[][] transitionRates) throws IOException {
        String tikzCode = generateEnvironmentTikZ(stageNames, transitionRates);

        // Create temporary directory
        Path tempDir = Files.createTempDirectory("line-tikz-env-");
        Path texFile = tempDir.resolve("network.tex");
        Path pdfFile = tempDir.resolve("network.pdf");

        // Write .tex file
        Files.write(texFile, tikzCode.getBytes(StandardCharsets.UTF_8));

        // Compile with pdflatex
        ProcessBuilder pb = new ProcessBuilder(
                "pdflatex",
                "-interaction=nonstopmode",
                "-output-directory=" + tempDir.toString(),
                texFile.toString()
        );
        pb.redirectErrorStream(true);
        pb.directory(tempDir.toFile());

        Process process = pb.start();
        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
        StringBuilder output = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            output.append(line).append("\n");
        }

        try {
            int exitCode = process.waitFor();
            if (exitCode != 0 || !Files.exists(pdfFile)) {
                throw new RuntimeException("pdflatex compilation failed:\n" + output.toString());
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("pdflatex was interrupted", e);
        }

        // Convert PDF to PNG using pdftoppm
        String pngPathWithoutExt = filePath.replaceAll("\\.png$", "");
        ProcessBuilder pbPng = new ProcessBuilder(
                "pdftoppm",
                "-png",
                "-r", String.valueOf(dpi),
                "-singlefile",
                pdfFile.toAbsolutePath().toString(),
                pngPathWithoutExt
        );
        pbPng.redirectErrorStream(true);

        Process processPng = pbPng.start();
        BufferedReader readerPng = new BufferedReader(new InputStreamReader(processPng.getInputStream()));
        StringBuilder outputPng = new StringBuilder();
        while ((line = readerPng.readLine()) != null) {
            outputPng.append(line).append("\n");
        }

        try {
            int exitCode = processPng.waitFor();
            if (exitCode != 0) {
                throw new RuntimeException("pdftoppm conversion failed:\n" + outputPng.toString());
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("pdftoppm was interrupted", e);
        }
    }
}
