{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:40:49.409651Z",
          "start_time": "2025-09-10T15:40:48.465392Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:18.720292Z",
          "iopub.execute_input": "2026-01-02T14:14:18.720392Z",
          "shell.execute_reply": "2026-01-02T14:14:19.568048Z",
          "iopub.status.idle": "2026-01-02T14:14:19.568371Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# CDF Response Time Analysis Example 1\n# Demonstrates cumulative distribution function analysis for a closed network\n\nmodel = Network('model')\n\n# Create closed queueing network with Delay and Queue nodes\nnode = [None] * 2  # using 0-based indexing\nnode[0] = Delay(model, 'Delay')\nnode[1] = Queue(model, 'Queue2', SchedStrategy.PS)\n\n# Single closed class with 1 job starting at Delay node\njobclass = [None] * 1  # using 0-based indexing\njobclass[0] = ClosedClass(model, 'Class1', 1, node[0], 0)\n\n# Service processes - match MATLAB exactly\nservProc1 = Exp(1/0.1)  # rate = 1/0.1 = 10\nnode[0].set_service(jobclass[0], servProc1)\n\nservProc2 = Erlang.fit_mean_and_scv(1, 1/3)  # mean=1, SCV=1/3\nnode[1].set_service(jobclass[0], servProc2)\n\n# Routing matrix - circular routing between the two nodes\nP = model.init_routing_matrix()\nP.set(jobclass[0], jobclass[0], node[0], node[1], 1.0)\nP.set(jobclass[0], jobclass[0], node[1], node[0], 1.0)\nmodel.link(P)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:40:49.438668Z",
          "start_time": "2025-09-10T15:40:49.413187Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:19.569453Z",
          "iopub.execute_input": "2026-01-02T14:14:19.569591Z",
          "iopub.status.idle": "2026-01-02T14:14:19.586105Z",
          "shell.execute_reply": "2026-01-02T14:14:19.585851Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Solve with JMT solver - aligned with JAR test scenario\nsolver = JMT(model, seed=23000, samples=10000)  # Aligned with JAR test: seed=23000, samples=10000\nFC = solver.cdf_respt()\n\nAvgRespTfromCDFSim = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nPowerMoment2_R = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nVariance_R = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nSqCoeffOfVariationRespTfromCDFSim = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\n\nfor i in range(model.get_number_of_stations()):\n    for c in range(model.get_number_of_classes()):\n        if FC[i][c] is not None and len(FC[i][c]) > 1:\n            # Calculate mean from CDF\n            diffs = np.diff(FC[i][c][:, 0])\n            values = FC[i][c][1:, 1]\n            AvgRespTfromCDFSim[i, c] = np.sum(diffs * values)\n            \n            # Calculate second moment and variance\n            PowerMoment2_R[i, c] = np.sum(diffs * (values ** 2))\n            Variance_R[i, c] = PowerMoment2_R[i, c] - AvgRespTfromCDFSim[i, c] ** 2\n            SqCoeffOfVariationRespTfromCDFSim[i, c] = Variance_R[i, c] / (AvgRespTfromCDFSim[i, c] ** 2)\n\n# Solve with Fluid solver - aligned with JAR test scenario (default options)\nsolver = FLD(model)  # Using default options like JAR test\nFC = solver.cdf_respt()\n\nAvgRespTfromCDFFluid = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nSqCoeffOfVariationRespTfromCDFFluid = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\n\nfor i in range(model.get_number_of_stations()):\n    for c in range(model.get_number_of_classes()):\n        if FC[i][c] is not None and len(FC[i][c]) > 1:\n            # Calculate mean from CDF  \n            diffs = np.diff(FC[i][c][:, 0])\n            values = FC[i][c][1:, 1]\n            AvgRespTfromCDFFluid[i, c] = np.sum(diffs * values)\n            \n            # Calculate second moment and variance\n            PowerMoment2_R_fluid = np.sum(diffs * (values ** 2))\n            Variance_R_fluid = PowerMoment2_R_fluid - AvgRespTfromCDFFluid[i, c] ** 2\n            SqCoeffOfVariationRespTfromCDFFluid[i, c] = Variance_R_fluid / (AvgRespTfromCDFFluid[i, c] ** 2)\n\n# Theoretical values from service processes\nAvgRespTfromTheory = np.array([servProc1.get_mean(), servProc2.get_mean()])\nSqCoeffOfVariationRespTfromTheory = np.array([servProc1.get_scv(), servProc2.get_scv()])\n\nprint('AvgRespTfromTheory =')\nprint(AvgRespTfromTheory)\nprint('AvgRespTfromCDFSim =')\nprint(AvgRespTfromCDFSim)\nprint('AvgRespTfromCDFFluid =')\nprint(AvgRespTfromCDFFluid)\nprint('SqCoeffOfVariationRespTfromTheory =')\nprint(SqCoeffOfVariationRespTfromTheory)\nprint('SqCoeffOfVariationRespTfromCDFSim =')\nprint(SqCoeffOfVariationRespTfromCDFSim)\nprint('SqCoeffOfVariationRespTfromCDFFluid =')\nprint(SqCoeffOfVariationRespTfromCDFFluid)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:40:52.777116Z",
          "start_time": "2025-09-10T15:40:49.476570Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:19.587338Z",
          "iopub.execute_input": "2026-01-02T14:14:19.587481Z",
          "iopub.status.idle": "2026-01-02T14:14:21.894288Z",
          "shell.execute_reply": "2026-01-02T14:14:21.893956Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "JMT Model: /tmp/workspace/jsim/8463926803365116084/jmodel.jsim\n",
            "numerical_values": [
              8.463926803365116e+18
            ]
          }
        },
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "JMT Model: /tmp/workspace/jsim/7291843160683793222/jmodel.jsim\n",
            "numerical_values": [
              7.291843160683793e+18
            ]
          }
        },
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "AvgRespTfromTheory =\n[0.1 1. ]\nAvgRespTfromCDFSim =\n[[0.099998  ]\n [0.99770622]]\nAvgRespTfromCDFFluid =\n[[0.10173051]\n [1.05190494]]\nSqCoeffOfVariationRespTfromTheory =\n[1.         0.33333333]\nSqCoeffOfVariationRespTfromCDFSim =\n[[1.01101745]\n [0.33645389]]\nSqCoeffOfVariationRespTfromCDFFluid =\n[[1.00189442]\n [0.37325078]]\n",
            "numerical_values": [
              0.1,
              1.0,
              0.099998,
              0.99770622,
              0.10173051,
              1.05190494,
              1.0,
              0.33333333,
              1.01101745,
              0.33645389,
              1.00189442,
              0.37325078
            ]
          }
        }
      ],
      "execution_count": 3
    }
  },
  "numerical_summary": {
    "cell_2": [
      8.463926803365116e+18,
      7.291843160683793e+18,
      0.1,
      1.0,
      0.099998,
      0.99770622,
      0.10173051,
      1.05190494,
      1.0,
      0.33333333,
      1.01101745,
      0.33645389,
      1.00189442,
      0.37325078
    ]
  },
  "metadata": {
    "notebook_path": "cdfRespT/cdf_respt_closed.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 3,
    "code_cells": 3,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}