{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:33.173045Z",
          "start_time": "2025-09-10T15:33:31.891772Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:22.817798Z",
          "iopub.execute_input": "2026-01-02T14:14:22.817884Z",
          "iopub.status.idle": "2026-01-02T14:14:23.598573Z",
          "shell.execute_reply": "2026-01-02T14:14:23.598159Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# CDF Response Time Analysis Example 2\n# Demonstrates class switching in a closed network with 3 classes\n\nmodel = Network('model')\n\n# Create closed queueing network with Delay and Queue nodes\nnode = [None] * 2  # using 0-based indexing\nnode[0] = Delay(model, 'Delay')\nnode[1] = Queue(model, 'Queue2', SchedStrategy.PS)\n\n# Three closed classes - only Class1 has initial population\njobclass = [None] * 3  # using 0-based indexing\njobclass[0] = ClosedClass(model, 'Class1', 1, node[0], 0)\njobclass[1] = ClosedClass(model, 'Class2', 0, node[0], 0)\njobclass[2] = ClosedClass(model, 'Class3', 0, node[0], 0)\n\n# Class1 doesn't complete (stays in the system for class switching)\njobclass[0].completes = False\n\n# Service processes at Delay node\nnode[0].set_service(jobclass[0], Exp(1/1))  # rate = 1\nnode[0].set_service(jobclass[1], Exp(1/1))  # rate = 1\nnode[0].set_service(jobclass[2], Exp(1/1))  # rate = 1\n\n# Service processes at Queue node\nnode[1].set_service(jobclass[0], Exp(1/1))      # rate = 1\nnode[1].set_service(jobclass[1], Erlang(1/2, 2)) # Erlang with rate=1/2, order=2\nnode[1].set_service(jobclass[2], Exp(1/0.01))   # rate = 100\n\n# Complex routing matrix with class switching\nP = model.init_routing_matrix()\n\n# Class 1 to Class 1: Delay->Queue2\nP.set(jobclass[0], jobclass[0], node[0], node[1], 1.0)\n\n# Class 1 to Class 2: Queue2->Delay (class switch)\nP.set(jobclass[0], jobclass[1], node[1], node[0], 1.0)\n\n# Class 2 to Class 1: Delay->Queue2 (class switch back)\nP.set(jobclass[1], jobclass[0], node[1], node[0], 1.0)\n\n# Class 2 to Class 2: Delay->Queue2\nP.set(jobclass[1], jobclass[1], node[0], node[1], 1.0)\n\n# Class 3 circulates within itself\nP.set(jobclass[2], jobclass[2], node[0], node[1], 1.0)\nP.set(jobclass[2], jobclass[2], node[1], node[0], 1.0)\n\nmodel.link(P)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:33.205964Z",
          "start_time": "2025-09-10T15:33:33.177729Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:23.599757Z",
          "iopub.execute_input": "2026-01-02T14:14:23.599937Z",
          "iopub.status.idle": "2026-01-02T14:14:23.627236Z",
          "shell.execute_reply": "2026-01-02T14:14:23.626867Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# NOTE: The JAR test shows that JMT getCdfRespT is not implemented for multi-class models\n# So we only implement the Fluid solver scenario that works\n\n# Solve with Fluid solver - aligned with JAR test scenario\noptions = FLD.default_options()\noptions.method = 'statedep'  # Aligned with JAR test: method=\"statedep\"\noptions.iter_max = 100  # Aligned with JAR test: iter_max=100\n\nsolver = FLD(model, options)\nAvgRespT = solver.avg_respt()\nprint('AvgRespT =')\nprint(AvgRespT)\n\n# Get CDF of response times\nFC = solver.cdf_respt()\n\n# Calculate statistics from CDF\nAvgRespTfromCDF = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nPowerMoment2_R = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nVariance_R = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nSqCoeffOfVariationRespTfromCDF = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\n\nfor i in range(model.get_number_of_stations()):\n    for c in range(model.get_number_of_classes()):\n        if FC[i][c] is not None and len(FC[i][c]) > 1:\n            # Calculate mean from CDF\n            diffs = np.diff(FC[i][c][:, 0])\n            values = FC[i][c][1:, 1]\n            AvgRespTfromCDF[i, c] = np.sum(diffs * values)\n            \n            # Calculate second moment and variance\n            PowerMoment2_R[i, c] = np.sum(diffs * (values ** 2))\n            Variance_R[i, c] = PowerMoment2_R[i, c] - AvgRespTfromCDF[i, c] ** 2\n            \n            # Avoid division by zero (like MATLAB's implicit handling)\n            if AvgRespTfromCDF[i, c] != 0:\n                SqCoeffOfVariationRespTfromCDF[i, c] = Variance_R[i, c] / (AvgRespTfromCDF[i, c] ** 2)\n            else:\n                SqCoeffOfVariationRespTfromCDF[i, c] = np.nan\n\nprint('AvgRespTfromCDF =')\nprint(AvgRespTfromCDF)\nprint('SqCoeffOfVariationRespTfromCDF =')\nprint(SqCoeffOfVariationRespTfromCDF)\n\n# Commented out JMT solver scenario - JAR test shows it's disabled for multi-class CDF models\n# # Solve with JMT solver - aligned with JAR test scenario (disabled in JAR)\n# # solver = JMT(model, seed=23000, samples=10000)\n# # FC_jmt = solver.cdf_respt()\n# # print(\"JMT solver CDF analysis would be here, but it's not implemented for multi-class models\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:36.620819Z",
          "start_time": "2025-09-10T15:33:33.240050Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:23.628482Z",
          "iopub.execute_input": "2026-01-02T14:14:23.628688Z",
          "shell.execute_reply": "2026-01-02T14:14:25.329770Z",
          "iopub.status.idle": "2026-01-02T14:14:25.330095Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "[[1. 1. 0.]\n [1. 4. 0.]]\nAvgRespT =\n[[1. 1. 0.]\n [1. 4. 0.]]\n",
            "numerical_values": [
              1.0,
              1.0,
              0.0,
              1.0,
              4.0,
              0.0,
              1.0,
              1.0,
              0.0,
              1.0,
              4.0,
              0.0
            ]
          }
        },
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "AvgRespTfromCDF =\n[[1.01613361 1.01613361 0.        ]\n [1.01613361 4.14757458 0.        ]]\nSqCoeffOfVariationRespTfromCDF =\n[[1.01365464 1.01365464        nan]\n [1.01365464 0.55767516        nan]]\n",
            "numerical_values": [
              1.01613361,
              1.01613361,
              0.0,
              1.01613361,
              4.14757458,
              0.0,
              1.01365464,
              1.01365464,
              1.01365464,
              0.55767516
            ]
          }
        }
      ],
      "execution_count": 3
    }
  },
  "numerical_summary": {
    "cell_2": [
      1.0,
      1.0,
      0.0,
      1.0,
      4.0,
      0.0,
      1.0,
      1.0,
      0.0,
      1.0,
      4.0,
      0.0,
      1.01613361,
      1.01613361,
      0.0,
      1.01613361,
      4.14757458,
      0.0,
      1.01365464,
      1.01365464,
      1.01365464,
      0.55767516
    ]
  },
  "metadata": {
    "notebook_path": "cdfRespT/cdf_respt_closed_threeclasses.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 3,
    "code_cells": 3,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}