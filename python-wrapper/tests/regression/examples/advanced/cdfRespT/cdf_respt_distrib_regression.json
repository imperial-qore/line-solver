{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:17.262747Z",
          "start_time": "2025-09-10T15:33:16.223932Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:26.210351Z",
          "iopub.execute_input": "2026-01-02T14:14:26.210429Z",
          "shell.execute_reply": "2026-01-02T14:14:26.988232Z",
          "iopub.status.idle": "2026-01-02T14:14:26.988536Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# CDF Response Time Analysis Example 4\n# Closed network with two classes and different service distributions\n\nmodel = Network('model')\n\n# Create closed queueing network\nnode = [None] * 2  # using 0-based indexing\nnode[0] = Delay(model, 'Delay')\nnode[1] = Queue(model, 'Queue1', SchedStrategy.PS)\n\n# Two closed classes with different populations\njobclass = [None] * 2  # using 0-based indexing\njobclass[0] = ClosedClass(model, 'Class1', 1, node[0], 0)  # 1 job of Class1\njobclass[1] = ClosedClass(model, 'Class2', 3, node[0], 0)  # 3 jobs of Class2\n\n# Service processes at Delay node\nnode[0].set_service(jobclass[0], Exp.fit_mean(1.0))           # Class1: Exp with mean=1.0\nnode[0].set_service(jobclass[1], Erlang.fit_mean_and_order(4.0, 2))  # Class2: Erlang with mean=4.0, order=2\n\n# Service processes at Queue1 node  \nnode[1].set_service(jobclass[0], Exp.fit_mean(2.0))           # Class1: Exp with mean=2.0\nnode[1].set_service(jobclass[1], HyperExp.fit_mean_and_scv(5.0, 30.0))  # Class2: HyperExp with mean=5.0, SCV=30.0\n\n# Routing matrix - independent circulation for each class\nP = model.init_routing_matrix()\n\n# Class 1 circular routing\nP.set(jobclass[0], jobclass[0], node[0], node[1], 1.0)\nP.set(jobclass[0], jobclass[0], node[1], node[0], 1.0)\n\n# Class 2 circular routing \nP.set(jobclass[1], jobclass[1], node[0], node[1], 1.0)\nP.set(jobclass[1], jobclass[1], node[1], node[0], 1.0)\n\nmodel.link(P)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:17.359159Z",
          "start_time": "2025-09-10T15:33:17.266601Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:26.989948Z",
          "iopub.execute_input": "2026-01-02T14:14:26.990142Z",
          "iopub.status.idle": "2026-01-02T14:14:27.026558Z",
          "shell.execute_reply": "2026-01-02T14:14:27.026260Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Solve with JMT solver - aligned with JAR test scenario\njmtoptions = JMT.default_options()\njmtoptions.samples = int(100000)  # Aligned with JAR test: samples=100000  \njmtoptions.seed = 23000  # Aligned with JAR test: seed=23000\n# Note: JAR test also uses keep=true, but Python wrapper may not have this option\nRDsim = JMT(model, jmtoptions).get_tran_cdf_respt()  # Using getTranCdfRespT like JAR test",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:21.659748Z",
          "start_time": "2025-09-10T15:33:17.372591Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:27.027765Z",
          "iopub.execute_input": "2026-01-02T14:14:27.027910Z",
          "iopub.status.idle": "2026-01-02T14:14:30.512716Z",
          "shell.execute_reply": "2026-01-02T14:14:30.512377Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "JMT Model: /tmp/workspace/jsim/4293269216438748859/jmodel.jsim\n",
            "numerical_values": [
              4.2932692164387487e+18
            ]
          }
        },
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "JMT Model: /tmp/workspace/jsim/18285138118279222630/jmodel.jsim\n",
            "numerical_values": [
              1.8285138118279223e+19
            ]
          }
        }
      ],
      "execution_count": 3
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Solve with Fluid solver - aligned with JAR test scenario (default options)\nRDfluid = FLD(model).cdf_respt()  # Using default options like JAR test",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:23.754803Z",
          "start_time": "2025-09-10T15:33:21.939642Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:30.513781Z",
          "iopub.execute_input": "2026-01-02T14:14:30.513872Z",
          "iopub.status.idle": "2026-01-02T14:14:31.779576Z",
          "shell.execute_reply": "2026-01-02T14:14:31.779220Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Plotting and comparison\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(model.get_number_of_stations(), 2, figsize=(12, 8))\n\nfor i in range(model.get_number_of_stations()):\n    # Class 1 plot - Plot CDF (not complementary CDF)\n    if RDsim[i][0] is not None and RDfluid[i][0] is not None:\n        # Data format is [CDF_value, time]\n        # No need for offset - (0,0) point has been removed\n        time_sim = RDsim[i][0][:, 1]    # Time values\n        cdf_sim = RDsim[i][0][:, 0]     # CDF values\n        time_fluid = RDfluid[i][0][:, 1]  # Time values\n        cdf_fluid = RDfluid[i][0][:, 0]   # CDF values\n        \n        axes[i, 0].semilogx(time_sim, cdf_sim, 'r', label='jmt-transient')\n        axes[i, 0].semilogx(time_fluid, cdf_fluid, '--', label='fluid-steady')\n        axes[i, 0].legend(loc='best')\n        axes[i, 0].set_ylabel('F(t) [CDF]')\n        axes[i, 0].set_xlabel('Time')\n        axes[i, 0].grid(True, alpha=0.3)\n        \n        # Get service process name for title\n        service_name = node[i].serviceProcess[0].name if hasattr(node[i], 'serviceProcess') else 'service'\n        axes[i, 0].set_title(f'CDF: Node {i}, Class 1, {service_name} service')\n    \n    # Class 2 plot - Plot CDF (not complementary CDF)\n    if RDsim[i][1] is not None and RDfluid[i][1] is not None:\n        # Data format is [CDF_value, time]\n        # No need for offset - (0,0) point has been removed\n        time_sim = RDsim[i][1][:, 1]    # Time values\n        cdf_sim = RDsim[i][1][:, 0]     # CDF values\n        time_fluid = RDfluid[i][1][:, 1]  # Time values\n        cdf_fluid = RDfluid[i][1][:, 0]   # CDF values\n        \n        axes[i, 1].semilogx(time_sim, cdf_sim, 'r', label='jmt-transient')\n        axes[i, 1].semilogx(time_fluid, cdf_fluid, '--', label='fluid-steady')\n        axes[i, 1].legend(loc='best')\n        axes[i, 1].set_ylabel('F(t) [CDF]')\n        axes[i, 1].set_xlabel('Time')\n        axes[i, 1].grid(True, alpha=0.3)\n        \n        # Get service process name for title\n        service_name = node[i].serviceProcess[1].name if hasattr(node[i], 'serviceProcess') else 'service'\n        axes[i, 1].set_title(f'CDF: Node {i}, Class 2, {service_name} service')\n\nplt.tight_layout()\nplt.show()\n\n# Calculate average response times from CDFs\n# Data format is [CDF_value, time]\nAvgRespTfromCDFfluid = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nAvgRespTfromCDFsim = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\n\nfor i in range(model.get_number_of_stations()):\n    for c in range(model.get_number_of_classes()):\n        # From Fluid CDF - format: [CDF_value, time]\n        if RDfluid[i][c] is not None and len(RDfluid[i][c]) > 1:\n            diffs = np.diff(RDfluid[i][c][:, 0])  # diff of CDF values (column 0)\n            values = RDfluid[i][c][1:, 1]         # time values (column 1)\n            AvgRespTfromCDFfluid[i, c] = np.sum(diffs * values)\n        \n        # From Simulation CDF - format: [CDF_value, time]\n        if RDsim[i][c] is not None and len(RDsim[i][c]) > 1:\n            diffs = np.diff(RDsim[i][c][:, 0])    # diff of CDF values (column 0)\n            values = RDsim[i][c][1:, 1]           # time values (column 1)\n            AvgRespTfromCDFsim[i, c] = np.sum(diffs * values)\n\nprint('AvgRespTfromCDFfluid =')\nprint(AvgRespTfromCDFfluid)\nprint('AvgRespTfromCDFsim =')\nprint(AvgRespTfromCDFsim)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:24.942192Z",
          "start_time": "2025-09-10T15:33:24.057021Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:14:31.780689Z",
          "iopub.execute_input": "2026-01-02T14:14:31.780786Z",
          "iopub.status.idle": "2026-01-02T14:14:32.489073Z",
          "shell.execute_reply": "2026-01-02T14:14:32.488833Z"
        }
      },
      "outputs": [
        {
          "output_type": "display_data",
          "execution_count": null,
          "metadata": {},
          "content": {
            "text/plain": "<Figure size 1200x800 with 4 Axes>",
            "numerical_values": [
              1200.0,
              800.0,
              4.0
            ],
            "image/png": "<image_data_length:99912>"
          }
        },
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "AvgRespTfromCDFfluid =\n[[1.22891074 4.47028993]\n [7.01190389 9.8065863 ]]\nAvgRespTfromCDFsim =\n[[ 1.00090578  3.96261867]\n [ 6.61339076 17.65171854]]\n",
            "numerical_values": [
              1.22891074,
              4.47028993,
              7.01190389,
              9.8065863,
              1.00090578,
              3.96261867,
              6.61339076,
              17.65171854
            ]
          }
        }
      ],
      "execution_count": 5
    }
  },
  "numerical_summary": {
    "cell_2": [
      4.2932692164387487e+18,
      1.8285138118279223e+19,
      100000.0,
      100000.0,
      23000.0,
      23000.0
    ],
    "cell_4": [
      1200.0,
      800.0,
      4.0,
      1.22891074,
      4.47028993,
      7.01190389,
      9.8065863,
      1.00090578,
      3.96261867,
      6.61339076,
      17.65171854
    ]
  },
  "metadata": {
    "notebook_path": "cdfRespT/cdf_respt_distrib.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 5,
    "code_cells": 5,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}