{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-29T17:23:34.442516Z",
          "start_time": "2025-07-29T17:23:34.438247Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:51.668300Z",
          "iopub.execute_input": "2026-01-02T14:15:51.668382Z",
          "iopub.status.idle": "2026-01-02T14:15:52.418847Z",
          "shell.execute_reply": "2026-01-02T14:15:52.418536Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# Create network\nmodel = Network('model')\n\n# Block 1: nodes\nnode1 = Delay(model, 'Delay')\nnode2 = Queue(model, 'Queue1', SchedStrategy.PS)\nnode3 = Queue(model, 'Queue2', SchedStrategy.PS)\nnode3.set_number_of_servers(2)  # Queue2 has 2 servers",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-29T17:23:34.501474Z",
          "start_time": "2025-07-29T17:23:34.499469Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:52.420161Z",
          "iopub.execute_input": "2026-01-02T14:15:52.420335Z",
          "iopub.status.idle": "2026-01-02T14:15:52.430911Z",
          "shell.execute_reply": "2026-01-02T14:15:52.430466Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Block 2: classes\nN = [1, 0, 4, 0]  # Population for each class\njobclass1 = ClosedClass(model, 'Class1', N[0], node1, 0)\njobclass2 = ClosedClass(model, 'Class2', N[1], node1, 0)\njobclass3 = ClosedClass(model, 'Class3', N[2], node1, 0)\njobclass4 = ClosedClass(model, 'Class4', N[3], node1, 0)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-29T17:23:34.552308Z",
          "start_time": "2025-07-29T17:23:34.549624Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:52.432349Z",
          "iopub.execute_input": "2026-01-02T14:15:52.432513Z",
          "iopub.status.idle": "2026-01-02T14:15:52.435851Z",
          "shell.execute_reply": "2026-01-02T14:15:52.435517Z"
        }
      },
      "outputs": [],
      "execution_count": 3
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Set service times for Delay\nnode1.set_service(jobclass1, Exp.fit_mean(1.0))\nnode1.set_service(jobclass2, Exp.fit_mean(1.0/2.0))  # Mean = 0.5\nnode1.set_service(jobclass3, Exp.fit_mean(1.0))\nnode1.set_service(jobclass4, Exp.fit_mean(1.0))\n\n# Set service times for Queue1\nnode2.set_service(jobclass1, Exp.fit_mean(1.0/3.0))  # Mean = 0.333\nnode2.set_service(jobclass2, Exp.fit_mean(1.0/4.0))  # Mean = 0.25\nnode2.set_service(jobclass3, Exp.fit_mean(1.0/5.0))  # Mean = 0.2\nnode2.set_service(jobclass4, Exp.fit_mean(1.0))\n\n# Set service times for Queue2\nnode3.set_service(jobclass1, Exp.fit_mean(1.0))\nnode3.set_service(jobclass2, Exp.fit_mean(1.0/3.0))  # Mean = 0.333\nnode3.set_service(jobclass3, Exp.fit_mean(1.0/5.0))  # Mean = 0.2\nnode3.set_service(jobclass4, Exp.fit_mean(1.0/2.0))  # Mean = 0.5",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-29T17:23:34.601467Z",
          "start_time": "2025-07-29T17:23:34.598526Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:52.436720Z",
          "iopub.execute_input": "2026-01-02T14:15:52.436830Z",
          "shell.execute_reply": "2026-01-02T14:15:52.442628Z",
          "iopub.status.idle": "2026-01-02T14:15:52.442937Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Block 3: routing with class switching\n# Create routing matrices for each class-to-class transition\nK = 4  # Number of classes\nP = {}\n\n# P[(i,j)] represents routing from class i to class j\n# Matrix dimensions: [from_node, to_node]\n\n# Class1 routing\nP[(jobclass1, jobclass1)] = np.array([[0,1,0], [0,0,1], [0,0,0]])\nP[(jobclass1, jobclass2)] = np.array([[0,0,0], [0,0,0], [1,0,0]])  # Class switch at Queue2\nP[(jobclass1, jobclass3)] = np.array([[0,0,0], [0,0,0], [0,0,0]])\nP[(jobclass1, jobclass4)] = np.array([[0,0,0], [0,0,0], [0,0,0]])\n\n# Class2 routing\nP[(jobclass2, jobclass1)] = np.array([[0,0,0], [0,0,0], [1,0,0]])  # Class switch at Queue2\nP[(jobclass2, jobclass2)] = np.array([[0,1,0], [0,0,1], [0,0,0]])\nP[(jobclass2, jobclass3)] = np.array([[0,0,0], [0,0,0], [0,0,0]])\nP[(jobclass2, jobclass4)] = np.array([[0,0,0], [0,0,0], [0,0,0]])\n\n# Class3 routing\nP[(jobclass3, jobclass1)] = np.array([[0,0,0], [0,0,0], [0,0,0]])\nP[(jobclass3, jobclass2)] = np.array([[0,0,0], [0,0,0], [0,0,0]])\nP[(jobclass3, jobclass3)] = np.array([[0,1,0], [0,0,1], [0,0,0]])\nP[(jobclass3, jobclass4)] = np.array([[0,0,0], [0,0,0], [1,0,0]])  # Class switch at Queue2\n\n# Class4 routing\nP[(jobclass4, jobclass1)] = np.array([[0,0,0], [0,0,0], [0,0,0]])\nP[(jobclass4, jobclass2)] = np.array([[0,0,0], [0,0,0], [0,0,0]])\nP[(jobclass4, jobclass3)] = np.array([[0,0,0], [0,0,0], [1,0,0]])  # Class switch at Queue2\nP[(jobclass4, jobclass4)] = np.array([[0,0,1], [0,0,0], [0,0,0]])  # Delay -> Queue2\n\nmodel.link(P)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-29T17:23:34.656960Z",
          "start_time": "2025-07-29T17:23:34.649657Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:52.444057Z",
          "iopub.execute_input": "2026-01-02T14:15:52.444165Z",
          "shell.execute_reply": "2026-01-02T14:15:52.516617Z",
          "iopub.status.idle": "2026-01-02T14:15:52.516922Z"
        }
      },
      "outputs": [],
      "execution_count": 5
    },
    "cell_5": {
      "cell_type": "code",
      "source": "# Set initial state for probability calculation\n# State format: [station][class] where -1 means ignored\nn = np.array([[-1,-1,-1,-1],   # Delay state (ignored)\n              [-1,-1,-1,-1],   # Queue1 state (ignored)\n              [1, 0, 2, 1]])   # Queue2 state: 1 Class1, 0 Class2, 2 Class3, 1 Class4\n\n# Set state for each node\nnodes = [node1, node2, node3]\nfor i in range(len(nodes)):\n    if not np.any(n[i] == -1):  # Only set state if not ignored\n        nodes[i].set_state(n[i])",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-29T17:23:34.701989Z",
          "start_time": "2025-07-29T17:23:34.698976Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:52.517957Z",
          "iopub.execute_input": "2026-01-02T14:15:52.518057Z",
          "shell.execute_reply": "2026-01-02T14:15:52.519874Z",
          "iopub.status.idle": "2026-01-02T14:15:52.520066Z"
        }
      },
      "outputs": [],
      "execution_count": 6
    },
    "cell_6": {
      "cell_type": "code",
      "source": "# Solve with CTMC for exact state probabilitiesoptions = Solver.defaultOptionsoptions.verbose = 1solver_ctmc = CTMC(model, options)#Pr_ctmc = solver_ctmc.prob_aggr(node3)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-29T17:23:34.752171Z",
          "start_time": "2025-07-29T17:23:34.748205Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:52.520751Z",
          "iopub.execute_input": "2026-01-02T14:15:52.520836Z",
          "shell.execute_reply": "2026-01-02T14:15:52.522009Z",
          "iopub.status.idle": "2026-01-02T14:15:52.522222Z"
        }
      },
      "outputs": [],
      "execution_count": 7
    },
    "cell_7": {
      "cell_type": "code",
      "source": "# Solve with NC (Normalizing Constant) method\nprint(\"\\n=== NC Solution (Normalizing Constants) ===\")\nsolver_nc = NC(model)\n\nPr_nc = solver_nc.prob_aggr(node3)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-18T06:59:02.162452Z",
          "start_time": "2025-09-18T06:59:02.091085Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:52.522887Z",
          "iopub.execute_input": "2026-01-02T14:15:52.522964Z",
          "iopub.status.idle": "2026-01-02T14:15:52.624841Z",
          "shell.execute_reply": "2026-01-02T14:15:52.624585Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "\n=== NC Solution (Normalizing Constants) ===\n"
          }
        }
      ],
      "execution_count": 8
    },
    "cell_8": {
      "cell_type": "code",
      "source": "#avg_table = solver_ctmc.avg_table()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-29T17:23:44.361501800Z",
          "start_time": "2025-07-29T17:23:34.849887Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:52.625764Z",
          "iopub.execute_input": "2026-01-02T14:15:52.625854Z",
          "shell.execute_reply": "2026-01-02T14:15:52.626909Z",
          "iopub.status.idle": "2026-01-02T14:15:52.627111Z"
        }
      },
      "outputs": [],
      "execution_count": 9
    }
  },
  "numerical_summary": {
    "cell_1": [
      1.0,
      1.0,
      2.0,
      1.0,
      3.0,
      2.0,
      3.0,
      2.0,
      2.0,
      2.0
    ],
    "cell_6": [
      1.0,
      3.0
    ],
    "cell_7": [
      3.0
    ]
  },
  "metadata": {
    "notebook_path": "stateProbabilities/statepr_aggr_large.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 9,
    "code_cells": 9,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}