{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:28.343862Z",
          "start_time": "2025-07-14T16:56:28.323135Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:26.116019Z",
          "iopub.execute_input": "2026-01-02T14:15:26.116143Z",
          "iopub.status.idle": "2026-01-02T14:15:27.050065Z",
          "shell.execute_reply": "2026-01-02T14:15:27.049679Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# Model parameters\nN = 4  # number of jobs in Class1\nc = 2  # number of servers\n\n# Create network\nmodel = Network('model')\nnode1 = Delay(model, 'Delay')\nnode2 = Queue(model, 'Queue1', SchedStrategy.PS)\n\n# Create job classes\njobclass1 = ClosedClass(model, 'Class1', N, node1, 0)\njobclass2 = ClosedClass(model, 'Class2', N // 2, node1, 0)  # N/2 = 2 jobs\n\n# Set service times\nnode1.set_service(jobclass1, Exp.fit_mean(1.0))   # Class1: mean = 1.0\nnode1.set_service(jobclass2, Exp.fit_mean(2.0))   # Class2: mean = 2.0\nnode2.set_service(jobclass1, Exp.fit_mean(1.5))   # Class1: mean = 1.5\nnode2.set_service(jobclass2, Exp.fit_mean(2.5))   # Class2: mean = 2.5\nnode2.set_number_of_servers(c)\n\n# Create routing matrix\nP = model.init_routing_matrix()\nP.set(jobclass1, jobclass1, node1, node2, 1.0)\nP.set(jobclass1, jobclass1, node2, node1, 1.0)\nP.set(jobclass2, jobclass2, node1, node2, 1.0)\nP.set(jobclass2, jobclass2, node2, node1, 1.0)\nmodel.link(P)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:28.482310Z",
          "start_time": "2025-07-14T16:56:28.461396Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.051428Z",
          "iopub.execute_input": "2026-01-02T14:15:27.051640Z",
          "shell.execute_reply": "2026-01-02T14:15:27.076736Z",
          "iopub.status.idle": "2026-01-02T14:15:27.077090Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "avg_table_mva=MVA(model, method='exact').avg_table()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:28.707364Z",
          "start_time": "2025-07-14T16:56:28.596669Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.078245Z",
          "iopub.execute_input": "2026-01-02T14:15:27.078425Z",
          "iopub.status.idle": "2026-01-02T14:15:27.197708Z",
          "shell.execute_reply": "2026-01-02T14:15:27.197441Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "  Station JobClass    QLen    Util   RespT  ResidT    ArvR    Tput\n0   Delay   Class1  0.8975  0.8975  1.0000  1.0000  0.8975  0.8975\n1   Delay   Class2  0.5116  0.5116  2.0000  2.0000  0.2558  0.2558\n2  Queue1   Class1  3.1025  0.6731  3.4568  3.4568  0.8975  0.8975\n3  Queue1   Class2  1.4884  0.3197  5.8190  5.8190  0.2558  0.2558\n",
            "numerical_values": [
              0.0,
              1.0,
              0.8975,
              0.8975,
              1.0,
              1.0,
              0.8975,
              0.8975,
              1.0,
              2.0,
              0.5116,
              0.5116,
              2.0,
              2.0,
              0.2558,
              0.2558,
              2.0,
              1.0,
              1.0,
              3.1025,
              0.6731,
              3.4568,
              3.4568,
              0.8975,
              0.8975,
              3.0,
              1.0,
              2.0,
              1.4884,
              0.3197,
              5.819,
              5.819,
              0.2558,
              0.2558
            ]
          }
        }
      ],
      "execution_count": 3
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Create load-dependent model\nldmodel = Network('ldmodel')\nldnode1 = Delay(ldmodel, 'Delay')\nldnode2 = Queue(ldmodel, 'Queue1', SchedStrategy.PS)\n\n# Create job classes for load-dependent model\nldjobclass1 = ClosedClass(ldmodel, 'Class1', N, ldnode1, 0)\nldjobclass2 = ClosedClass(ldmodel, 'Class2', N // 2, ldnode1, 0)\n\n# Set service times for load-dependent model\nldnode1.set_service(ldjobclass1, Exp.fit_mean(1.0))\nldnode1.set_service(ldjobclass2, Exp.fit_mean(2.0))\nldnode2.set_service(ldjobclass1, Exp.fit_mean(1.5))\nldnode2.set_service(ldjobclass2, Exp.fit_mean(2.5))\n\n# Set load dependence: min(total_jobs+1, 2) servers available\n# Create load dependence matrix where rows are total jobs (0 to 6) and columns are service rates\nmax_jobs = N + N // 2  # 4 + 2 = 6 total jobs\nld_matrix = np.zeros((max_jobs + 1, 2))  # (total_jobs+1) x num_classes\n\nfor total_jobs in range(max_jobs + 1):\n    servers_available = min(total_jobs + 1, c)\n    ld_matrix[total_jobs, 0] = servers_available  # Class1 scaling\n    ld_matrix[total_jobs, 1] = servers_available  # Class2 scaling\n\nldnode2.set_load_dependence(ld_matrix)\nldnode2.set_number_of_servers(c)\n\n# Create routing matrix for load-dependent model\nP_ld = ldmodel.init_routing_matrix()\nP_ld.set(ldjobclass1, ldjobclass1, ldnode1, ldnode2, 1.0)\nP_ld.set(ldjobclass1, ldjobclass1, ldnode2, ldnode1, 1.0)\nP_ld.set(ldjobclass2, ldjobclass2, ldnode1, ldnode2, 1.0)\nP_ld.set(ldjobclass2, ldjobclass2, ldnode2, ldnode1, 1.0)\nldmodel.link(P_ld)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:29.007637Z",
          "start_time": "2025-07-14T16:56:28.946850Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.198651Z",
          "iopub.execute_input": "2026-01-02T14:15:27.198761Z",
          "shell.execute_reply": "2026-01-02T14:15:27.209590Z",
          "iopub.status.idle": "2026-01-02T14:15:27.209943Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Solve load-dependent model with CTMC\ntry:\n    lldAvgTableCTMC=CTMC(ldmodel).avg_table()\n    print(lldAvgTableCTMC)\nexcept Exception as e:\n    print(f\"CTMC solver error: {type(e).__name__}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:29.353313Z",
          "start_time": "2025-07-14T16:56:29.183476Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.211209Z",
          "iopub.execute_input": "2026-01-02T14:15:27.211351Z",
          "iopub.status.idle": "2026-01-02T14:15:27.218924Z",
          "shell.execute_reply": "2026-01-02T14:15:27.218660Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "CTMC solver error: org.ejml.MatrixDimensionException\n"
          }
        }
      ],
      "execution_count": 5
    },
    "cell_5": {
      "cell_type": "code",
      "source": "# Solve with NC methods - may fail on multi-station load-dependent models\ntry:\n    lldAvgTableNC=NC(ldmodel).avg_table()\n    print(lldAvgTableNC)\nexcept Exception as e:\n    print(f\"NC solver limitation: {type(e).__name__}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:33.332181Z",
          "start_time": "2025-07-14T16:56:33.180252Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.219786Z",
          "iopub.execute_input": "2026-01-02T14:15:27.219884Z",
          "iopub.status.idle": "2026-01-02T14:15:27.225088Z",
          "shell.execute_reply": "2026-01-02T14:15:27.224772Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "NC solver limitation: org.ejml.MatrixDimensionException\n"
          }
        }
      ],
      "execution_count": 6
    },
    "cell_6": {
      "cell_type": "code",
      "source": "try:\n    lldAvgTableRD=NC(ldmodel, method='rd').avg_table()\n    print(lldAvgTableRD)\nexcept Exception as e:\n    print(f\"NC(rd) solver limitation: {type(e).__name__}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:33.332181Z",
          "start_time": "2025-07-14T16:56:33.180252Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.226131Z",
          "iopub.execute_input": "2026-01-02T14:15:27.226259Z",
          "iopub.status.idle": "2026-01-02T14:15:27.228692Z",
          "shell.execute_reply": "2026-01-02T14:15:27.228384Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "NC(rd) solver limitation: org.ejml.MatrixDimensionException\n"
          }
        }
      ],
      "execution_count": 7
    },
    "cell_7": {
      "cell_type": "code",
      "source": "try:\n    lldAvgTableNRP=NC(ldmodel, method='nrp').avg_table()\n    print(lldAvgTableNRP)\nexcept Exception as e:\n    print(f\"NC(nrp) solver limitation: {type(e).__name__}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:33.332181Z",
          "start_time": "2025-07-14T16:56:33.180252Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.229533Z",
          "iopub.execute_input": "2026-01-02T14:15:27.229657Z",
          "iopub.status.idle": "2026-01-02T14:15:27.232836Z",
          "shell.execute_reply": "2026-01-02T14:15:27.232167Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "NC(nrp) solver limitation: org.ejml.MatrixDimensionException\n"
          }
        }
      ],
      "execution_count": 8
    },
    "cell_8": {
      "cell_type": "code",
      "source": "try:\n    lldAvgTableNRL=NC(ldmodel, method='nrl').avg_table()\n    print(lldAvgTableNRL)\nexcept Exception as e:\n    print(f\"NC(nrl) solver limitation: {type(e).__name__}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:33.332181Z",
          "start_time": "2025-07-14T16:56:33.180252Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.234304Z",
          "iopub.execute_input": "2026-01-02T14:15:27.234449Z",
          "shell.execute_reply": "2026-01-02T14:15:27.236615Z",
          "iopub.status.idle": "2026-01-02T14:15:27.236915Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "NC(nrl) solver limitation: org.ejml.MatrixDimensionException\n"
          }
        }
      ],
      "execution_count": 9
    },
    "cell_9": {
      "cell_type": "code",
      "source": "# Solve with MVA methods\ntry:\n    lldAvgTableMVALD=MVA(ldmodel, method='exact').avg_table()\n    print(lldAvgTableMVALD)\nexcept Exception as e:\n    print(f\"MVA(exact) solver error: {type(e).__name__}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:36.194161Z",
          "start_time": "2025-07-14T16:56:35.925796Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.237922Z",
          "iopub.execute_input": "2026-01-02T14:15:27.238023Z",
          "shell.execute_reply": "2026-01-02T14:15:27.239985Z",
          "iopub.status.idle": "2026-01-02T14:15:27.240249Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "MVA(exact) solver error: org.ejml.MatrixDimensionException\n"
          }
        }
      ],
      "execution_count": 10
    },
    "cell_10": {
      "cell_type": "code",
      "source": "try:\n    lldAvgTableQD=MVA(ldmodel, method='qd').avg_table()\n    print(lldAvgTableQD)\nexcept Exception as e:\n    print(f\"MVA(qd) solver error: {type(e).__name__}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T16:56:36.194161Z",
          "start_time": "2025-07-14T16:56:35.925796Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:27.241003Z",
          "iopub.execute_input": "2026-01-02T14:15:27.241091Z",
          "shell.execute_reply": "2026-01-02T14:15:27.242858Z",
          "iopub.status.idle": "2026-01-02T14:15:27.243107Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "MVA(qd) solver error: org.ejml.MatrixDimensionException\n"
          }
        }
      ],
      "execution_count": 11
    }
  },
  "numerical_summary": {
    "cell_2": [
      0.0,
      1.0,
      0.8975,
      0.8975,
      1.0,
      1.0,
      0.8975,
      0.8975,
      1.0,
      2.0,
      0.5116,
      0.5116,
      2.0,
      2.0,
      0.2558,
      0.2558,
      2.0,
      1.0,
      1.0,
      3.1025,
      0.6731,
      3.4568,
      3.4568,
      0.8975,
      0.8975,
      3.0,
      1.0,
      2.0,
      1.4884,
      0.3197,
      5.819,
      5.819,
      0.2558,
      0.2558
    ]
  },
  "metadata": {
    "notebook_path": "loadDependent/ld_multiserver_ps_twoclasses.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 11,
    "code_cells": 11,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}