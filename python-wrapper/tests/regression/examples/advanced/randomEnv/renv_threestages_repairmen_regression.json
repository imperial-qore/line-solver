{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:32.466547Z",
          "iopub.execute_input": "2026-01-02T14:15:32.466638Z",
          "iopub.status.idle": "2026-01-02T14:15:33.347800Z",
          "shell.execute_reply": "2026-01-02T14:15:33.347414Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "def circul(c):\n    \"\"\"Returns a circulant matrix of order c.\n    \n    Args:\n        c: Either an integer (order) or a vector for the first row\n        \n    Returns:\n        numpy.ndarray: Circulant matrix\n    \"\"\"\n    if np.isscalar(c):\n        if c == 1:\n            return np.array([[1]])\n        else:\n            v = np.zeros(c)\n            v[-1] = 1  # Last element = 1\n            return circul(v)\n    \n    # c is a vector\n    n = len(c)\n    C = np.zeros((n, n))\n    \n    for i in range(n):\n        for j in range(n):\n            C[i, j] = c[(j - i) % n]\n    \n    return C\n\ndef renv_genqn(rate, N):\n    \"\"\"Helper function to generate a queueing network for random environment advanced.\"\"\"\n    qnet = Network('qn1')\n    \n    node = np.empty(2, dtype=object)\n    node[0] = Delay(qnet, 'Queue1')\n    node[1] = Queue(qnet, 'Queue2', SchedStrategy.PS)\n    \n    jobclass = np.empty(1, dtype=object)\n    jobclass[0] = ClosedClass(qnet, 'Class1', N, node[0], 0)\n    \n    node[0].set_service(jobclass[0], Exp(rate[0]))\n    node[1].set_service(jobclass[0], Exp(rate[1]))\n    \n    P = qnet.init_routing_matrix()\n    P.set(jobclass[0], jobclass[0], [[0, 1], [1, 0]])\n    qnet.link(P)\n    \n    return qnet",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:33.349116Z",
          "iopub.execute_input": "2026-01-02T14:15:33.349301Z",
          "shell.execute_reply": "2026-01-02T14:15:33.351875Z",
          "iopub.status.idle": "2026-01-02T14:15:33.352175Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Model parameters\nN = 2  # Job population  \nM = 2  # Number of stations\nE = 3  # Number of environment stages\n\n# Create environment model\nenvModel = Environment('MyEnv', E)\nenvName = ['Stage1', 'Stage2', 'Stage3']\nenvType = ['UP', 'DOWN', 'FAST']\n\n# Create rate matrix\nrate = np.ones((M, E))\nrate[M-1, :] = np.arange(1, E+1)  # rate(M,1:E)=(1:E)\nrate[0, :] = np.arange(E, 0, -1)  # rate(1,1:E)=(E:-1:1)\n\nprint(f\"Rate matrix:\")\nprint(rate)",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:33.353191Z",
          "iopub.execute_input": "2026-01-02T14:15:33.353305Z",
          "shell.execute_reply": "2026-01-02T14:15:33.359218Z",
          "iopub.status.idle": "2026-01-02T14:15:33.359509Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "Rate matrix:\n[[3. 2. 1.]\n [1. 2. 3.]]\n",
            "numerical_values": [
              3.0,
              2.0,
              1.0,
              1.0,
              2.0,
              3.0
            ]
          }
        }
      ],
      "execution_count": 3
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Create queueing networks for each environment stage\nqn1 = renv_genqn(rate[:, 0], N)\nqn2 = renv_genqn(rate[:, 1], N)\nqn3 = renv_genqn(rate[:, 2], N)\n\nenvSubModel = [qn1, qn2, qn3]\n\n# Add stages to environment model\nfor e in range(E):\n    envModel.add_stage(e, envName[e], envType[e], envSubModel[e])",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:33.360399Z",
          "iopub.execute_input": "2026-01-02T14:15:33.360499Z",
          "iopub.status.idle": "2026-01-02T14:15:33.385076Z",
          "shell.execute_reply": "2026-01-02T14:15:33.384780Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Define environment transition rates using circulant matrix\nenvRates = circul(3)  # Creates a 3x3 circulant matrix\n\nprint(f\"Environment transition rates (circulant matrix):\")\nprint(envRates)\n\n# Add transitions with Erlang distributions\nfor e in range(E):\n    for h in range(E):\n        if envRates[e, h] > 0:\n            mean_time = 1.0 / envRates[e, h]\n            order = e + h  # Erlang order based on stage indices\n            if order == 0:\n                order = 1  # Minimum order is 1\n            envModel.add_transition(e, h, Erlang.fit_mean_and_order(mean_time, order))",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:33.386233Z",
          "iopub.execute_input": "2026-01-02T14:15:33.386349Z",
          "shell.execute_reply": "2026-01-02T14:15:33.390401Z",
          "iopub.status.idle": "2026-01-02T14:15:33.390694Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "Environment transition rates (circulant matrix):\n[[0. 0. 1.]\n [1. 0. 0.]\n [0. 1. 0.]]\n",
            "numerical_values": [
              0.0,
              0.0,
              1.0,
              1.0,
              0.0,
              0.0,
              0.0,
              1.0,
              0.0
            ]
          }
        }
      ],
      "execution_count": 5
    },
    "cell_5": {
      "cell_type": "markdown",
      "source": "The metasolver considers an environment with 3 stages and a queueing network with 2 stations.\nThis example illustrates the computation of the infinitesimal generator of the system.",
      "metadata": {},
      "outputs": [],
      "execution_count": null
    },
    "cell_6": {
      "cell_type": "code",
      "source": "# Create solvers for each submodel using CTMCsolvers = np.empty(E, dtype=object)for e in range(E):    solvers[e] = CTMC(envSubModel[e])# Create environment solverenvSolver = ENV(envModel, solvers)# Get resultstry:    # Try to get the generator (infinitesimal generator matrix)    try:        generator_result = envSolver.generator()        print(\"Infinitesimal generator computation completed\")        print(f\"Generator result type: {type(generator_result)}\")        if hasattr(generator_result, 'shape'):            print(f\"Generator shape: {generator_result.shape}\")        else:            print(f\"Generator result: {generator_result}\")    except Exception as gen_error:        print(f\"Generator computation error: {gen_error}\")        print(\"Note: getGenerator() may not be fully implemented in Python version\")        # Alternative: Get ensemble averages    try:        avgTable = envSolver.ensemble_avg()        print(\"\\nEnsemble average performance metrics:\")        print(avgTable)    except Exception as avg_error:        print(f\"\\nEnsemble average error: {avg_error}\")        except Exception as e:    print(f\"Error during solving: {e}\")    print(\"Note: Some environment solver features may not be fully implemented in the Python version\")",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:33.392069Z",
          "iopub.execute_input": "2026-01-02T14:15:33.392198Z",
          "shell.execute_reply": "2026-01-02T14:15:33.393794Z",
          "iopub.status.idle": "2026-01-02T14:15:33.394094Z"
        }
      },
      "outputs": [],
      "execution_count": 6
    }
  },
  "numerical_summary": {
    "cell_2": [
      3.0,
      2.0,
      1.0,
      1.0,
      2.0,
      3.0
    ],
    "cell_3": [
      1.0,
      0.0,
      2.0,
      1.0,
      3.0,
      2.0,
      1.0,
      2.0,
      3.0
    ],
    "cell_4": [
      0.0,
      0.0,
      1.0,
      1.0,
      0.0,
      0.0,
      0.0,
      1.0,
      0.0,
      3.0,
      3.0,
      3.0,
      0.0,
      1.0,
      0.0,
      1.0,
      1.0
    ],
    "cell_5": [
      3.0,
      2.0
    ]
  },
  "metadata": {
    "notebook_path": "randomEnv/renv_threestages_repairmen.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 7,
    "code_cells": 6,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}