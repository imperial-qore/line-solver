{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.SILENT)",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:15.267630Z",
          "iopub.execute_input": "2026-01-02T14:15:15.267758Z",
          "iopub.status.idle": "2026-01-02T14:15:16.100810Z",
          "shell.execute_reply": "2026-01-02T14:15:16.100414Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "model = LayeredNetwork('cacheInLayeredNetwork')\n\n# Client\nP1 = Processor(model, 'P1', 1, SchedStrategy.PS)\nT1 = Task(model, 'T1', 1, SchedStrategy.REF).on(P1)\nE1 = Entry(model, 'E1').on(T1)\n\n# Cache task\ntotalitems = 4\ncachecapacity = 2\n# Create uniform access probabilities using Python list\naccess_probs = [1.0 / totalitems] * totalitems\npAccess = DiscreteSampler(access_probs)\nPC = Processor(model, 'PC', 1, SchedStrategy.PS)\nC2 = CacheTask(model, 'C2', totalitems, cachecapacity, ReplacementStrategy.RR, 1).on(PC)\nI2 = ItemEntry(model, 'I2', totalitems, pAccess).on(C2)\n\n# Definition of activities\nA1 = Activity(model, 'A1', Immediate()).on(T1).bound_to(E1).synch_call(I2, 1)\nAC2 = Activity(model, 'AC2', Immediate()).on(C2).bound_to(I2)\nAC2h = Activity(model, 'AC2h', Exp(1.0)).on(C2).replies_to(I2)  # Cache hit\nAC2m = Activity(model, 'AC2m', Exp(0.5)).on(C2).replies_to(I2)  # Cache miss\n\n# Add cache access precedence\nC2.add_precedence(ActivityPrecedence.cache_access(AC2, [AC2h, AC2m]))",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:16.102159Z",
          "iopub.execute_input": "2026-01-02T14:15:16.102381Z",
          "shell.execute_reply": "2026-01-02T14:15:16.168252Z",
          "iopub.status.idle": "2026-01-02T14:15:16.168625Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "lnoptions = LN.default_options()\n# lnoptions.iter_max = 1  # Note: iter_max option may not be available\nlnoptions.verbose = True\noptions = MVA.default_options()\noptions.verbose = False\n\nsolver = LN(model, lambda model: MVA(model, options), lnoptions)\nAvgTable = solver.avg_table()",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-02T14:15:16.169864Z",
          "iopub.execute_input": "2026-01-02T14:15:16.170007Z",
          "iopub.status.idle": "2026-01-02T14:15:16.432305Z",
          "shell.execute_reply": "2026-01-02T14:15:16.432024Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "   Node   NodeType    QLen    Util  RespT  ResidT  ArvR    Tput\n0    P1  Processor     NaN  0.0000    NaN     NaN   NaN     NaN\n1    PC  Processor     NaN  1.0000    NaN     NaN   NaN     NaN\n2    T1       Task  1.0000  0.0000    NaN     0.0   NaN  0.6667\n3    C2       Task  1.0000  1.0000    NaN     1.5   NaN  0.6667\n4    E1      Entry  1.0000     NaN    1.5     NaN   NaN  0.6667\n5    I2      Entry  1.0000     NaN    1.5     NaN   NaN  0.6667\n6    A1   Activity  1.0000  0.0000    1.5     0.0   NaN  0.6667\n7   AC2   Activity  0.0000  0.0000    0.0     0.0   NaN  0.0000\n8  AC2h   Activity  0.3333  0.3333    1.0     0.5   NaN  0.3333\n9  AC2m   Activity  0.6667  0.6667    2.0     1.0   NaN  0.3333\n",
            "numerical_values": [
              0.0,
              1.0,
              0.0,
              1.0,
              1.0,
              2.0,
              1.0,
              1.0,
              0.0,
              0.0,
              0.6667,
              3.0,
              2.0,
              1.0,
              1.0,
              1.5,
              0.6667,
              4.0,
              1.0,
              1.0,
              1.5,
              0.6667,
              5.0,
              2.0,
              1.0,
              1.5,
              0.6667,
              6.0,
              1.0,
              1.0,
              0.0,
              1.5,
              0.0,
              0.6667,
              7.0,
              2.0,
              0.0,
              0.0,
              0.0,
              0.0,
              0.0,
              8.0,
              2.0,
              0.3333,
              0.3333,
              1.0,
              0.5,
              0.3333,
              9.0,
              2.0,
              0.6667,
              0.6667,
              2.0,
              1.0,
              0.3333
            ]
          }
        }
      ],
      "execution_count": 3
    }
  },
  "numerical_summary": {
    "cell_2": [
      0.0,
      1.0,
      0.0,
      1.0,
      1.0,
      2.0,
      1.0,
      1.0,
      0.0,
      0.0,
      0.6667,
      3.0,
      2.0,
      1.0,
      1.0,
      1.5,
      0.6667,
      4.0,
      1.0,
      1.0,
      1.5,
      0.6667,
      5.0,
      2.0,
      1.0,
      1.5,
      0.6667,
      6.0,
      1.0,
      1.0,
      0.0,
      1.5,
      0.0,
      0.6667,
      7.0,
      2.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      8.0,
      2.0,
      0.3333,
      0.3333,
      1.0,
      0.5,
      0.3333,
      9.0,
      2.0,
      0.6667,
      0.6667,
      2.0,
      1.0,
      0.3333,
      1.0
    ]
  },
  "metadata": {
    "notebook_path": "layeredCQ/lcq_singlehost.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 3,
    "code_cells": 3,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}