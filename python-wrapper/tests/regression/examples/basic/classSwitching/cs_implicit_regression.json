{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T04:53:11.106846Z",
          "start_time": "2025-07-15T04:53:04.629572Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:08:15.636253Z",
          "iopub.execute_input": "2026-01-02T14:08:15.636339Z",
          "shell.execute_reply": "2026-01-02T14:08:16.401177Z",
          "iopub.status.idle": "2026-01-02T14:08:16.401625Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# Class switching example 1\n# A basic M/M/1 with explicit definition of a ClassSwitch node\n# Recommended ClassSwitch declaration style\nmodel = Network('mm1cs')",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T04:53:12.112104Z",
          "start_time": "2025-07-15T04:53:11.991560Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:08:16.402979Z",
          "iopub.execute_input": "2026-01-02T14:08:16.403225Z",
          "iopub.status.idle": "2026-01-02T14:08:16.409615Z",
          "shell.execute_reply": "2026-01-02T14:08:16.409275Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Block 1: nodes\nnode = np.empty(4, dtype=object)\nnode[0] = Source(model, 'Source 1')\nnode[1] = Queue(model, 'Queue 1', SchedStrategy.FCFS)\nnode[2] = Sink(model, 'Sink 1')\nnode[3] = ClassSwitch(model, 'ClassSwitch 1')\n\n# Block 2: classes\njobclass = np.empty(2, dtype=object)\njobclass[0] = OpenClass(model, 'Class1', 0)\njobclass[1] = OpenClass(model, 'Class2', 0)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T04:53:13.370705Z",
          "start_time": "2025-07-15T04:53:13.159258Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:08:16.410507Z",
          "iopub.execute_input": "2026-01-02T14:08:16.410624Z",
          "shell.execute_reply": "2026-01-02T14:08:16.419676Z",
          "iopub.status.idle": "2026-01-02T14:08:16.420053Z"
        }
      },
      "outputs": [],
      "execution_count": 3
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Service configurations\nnode[0].set_arrival(jobclass[0], Exp.fit_mean(10.000000))  # (Source 1,Class1)\nnode[0].set_arrival(jobclass[1], Exp.fit_mean(2.000000))   # (Source 1,Class2)\nnode[1].set_service(jobclass[0], Exp.fit_mean(1.000000))   # (Queue 1,Class1)\nnode[1].set_service(jobclass[1], Exp.fit_mean(1.000000))   # (Queue 1,Class2)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T04:53:13.646692Z",
          "start_time": "2025-07-15T04:53:13.573501Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:08:16.421387Z",
          "iopub.execute_input": "2026-01-02T14:08:16.421561Z",
          "iopub.status.idle": "2026-01-02T14:08:16.429030Z",
          "shell.execute_reply": "2026-01-02T14:08:16.428475Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Block 3: topology\n# The class switching matrix can now be declared after the classes, so the\n# ClassSwitch node can be declared outside Block 1.\ncsmatrix = node[3].init_class_switch_matrix()  # element (i,j) = probability that class i switches to j\n\n# Get class indices for the matrix\nclass1_idx = jobclass[0].get_index()\nclass2_idx = jobclass[1].get_index()\n\n# Set class switching probabilities using array indexing\ncsmatrix[class1_idx, class1_idx] = 0.3\ncsmatrix[class1_idx, class2_idx] = 0.7\ncsmatrix[class2_idx, class1_idx] = 1.0\nnode[3].set_class_switching_matrix(csmatrix)\n\nP = model.init_routing_matrix()  # initialize routing matrix\nP.set(jobclass[0], jobclass[0], node[0], node[3], 1.0)  # (Source 1,Class1) -> (ClassSwitch 1,Class1)\nP.set(jobclass[0], jobclass[0], node[1], node[2], 1.0)  # (Queue 1,Class1) -> (Sink 1,Class1)\nP.set(jobclass[0], jobclass[0], node[3], node[1], 1.0)  # (ClassSwitch 1,Class1) -> (Queue 1,Class1)\nP.set(jobclass[1], jobclass[1], node[0], node[3], 1.0)  # (Source 1,Class2) -> (ClassSwitch 1,Class2)\nP.set(jobclass[1], jobclass[1], node[1], node[2], 1.0)  # (Queue 1,Class2) -> (Sink 1,Class2)\nP.set(jobclass[1], jobclass[1], node[3], node[1], 1.0)  # (ClassSwitch 1,Class2) -> (Queue 1,Class2)\nmodel.link(P)\n#model.printRoutingMatrix()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T04:53:13.953344Z",
          "start_time": "2025-07-15T04:53:13.782782Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:08:16.430345Z",
          "iopub.execute_input": "2026-01-02T14:08:16.430506Z",
          "shell.execute_reply": "2026-01-02T14:08:16.508184Z",
          "iopub.status.idle": "2026-01-02T14:08:16.508498Z"
        }
      },
      "outputs": [],
      "execution_count": 5
    },
    "cell_5": {
      "cell_type": "code",
      "source": "# Solve\nsolver = MVA(model)\nAvgTable = solver.avg_chain_table()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T04:53:15.431963Z",
          "start_time": "2025-07-15T04:53:14.024942Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:08:16.509651Z",
          "iopub.execute_input": "2026-01-02T14:08:16.509810Z",
          "shell.execute_reply": "2026-01-02T14:08:16.621887Z",
          "iopub.status.idle": "2026-01-02T14:08:16.622126Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "    Station   Chain    QLen  Util   RespT  ResidT  ArvR  Tput\n1  Source 1  Chain2  0.0000  0.00  0.0000  0.0000  0.00  0.50\n3   Queue 1  Chain2  0.1765  0.15  1.1765  0.3529  0.15  0.15\n",
            "numerical_values": [
              1.0,
              1.0,
              2.0,
              0.0,
              0.0,
              0.0,
              0.0,
              0.0,
              0.5,
              3.0,
              1.0,
              2.0,
              0.1765,
              0.15,
              1.1765,
              0.3529,
              0.15,
              0.15
            ]
          }
        }
      ],
      "execution_count": 6
    }
  },
  "numerical_summary": {
    "cell_1": [
      1.0,
      1.0,
      1.0
    ],
    "cell_5": [
      1.0,
      1.0,
      2.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.0,
      0.5,
      3.0,
      1.0,
      2.0,
      0.1765,
      0.15,
      1.1765,
      0.3529,
      0.15,
      0.15
    ]
  },
  "metadata": {
    "notebook_path": "classSwitching/cs_implicit.ipynb",
    "source_dir": "examples/basic",
    "total_cells": 6,
    "code_cells": 6,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}