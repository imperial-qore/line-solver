{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:23:08.471193Z",
          "start_time": "2025-07-30T22:23:07.579672Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:13:16.901622Z",
          "iopub.execute_input": "2026-01-02T14:13:16.901744Z",
          "iopub.status.idle": "2026-01-02T14:13:17.774133Z",
          "shell.execute_reply": "2026-01-02T14:13:17.773693Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# Model parameters\n# Arrival rates for each class (scaled down by factor 50)\nlambda_rates = np.array([1, 2])  # [Class1, Class2] base rates\nlambda_rates = lambda_rates / 50  # Scale down: [0.02, 0.04]\n\n# Service time matrix D(i,r): mean service time of class r at station i\n# Station 1: Class1=10, Class2=5\n# Station 2: Class1=5,  Class2=9\nD = np.array([[10, 5],\n              [5, 9]])\n\n# Delay station service times Z(r): mean service time of class r at delay\nZ = np.array([91, 92])  # [Class1=91, Class2=92]\n\nprint(\"Model parameters:\")\nprint(f\"Arrival rates: {lambda_rates}\")\nprint(f\"Service time matrix D:\\n{D}\")\nprint(f\"Delay service times Z: {Z}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:23:08.478583Z",
          "start_time": "2025-07-30T22:23:08.474107Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:13:17.777913Z",
          "iopub.execute_input": "2026-01-02T14:13:17.778161Z",
          "iopub.status.idle": "2026-01-02T14:13:17.781321Z",
          "shell.execute_reply": "2026-01-02T14:13:17.780971Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "Model parameters:\nArrival rates: [0.02 0.04]\nService time matrix D:\n[[10  5]\n [ 5  9]]\nDelay service times Z: [91 92]\n",
            "numerical_values": [
              0.02,
              0.04,
              10.0,
              5.0,
              5.0,
              9.0,
              91.0,
              92.0
            ]
          }
        }
      ],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Create tandem PS network with infinite servers\nmodel = Network.tandemPsInf(lambda_rates, D, Z)\n\nprint(f\"Tandem PS network created with {model.get_number_of_nodes()} nodes and {model.get_number_of_classes()} classes\")\nprint(f\"Node names: {[node.get_name() for node in model.nodes()]}\")\nprint(f\"Class names: {[cls.get_name() for cls in model.classes()]}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:23:08.842395Z",
          "start_time": "2025-07-30T22:23:08.590174Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:13:17.782432Z",
          "iopub.execute_input": "2026-01-02T14:13:17.782592Z",
          "iopub.status.idle": "2026-01-02T14:13:17.815684Z",
          "shell.execute_reply": "2026-01-02T14:13:17.815216Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "Tandem PS network created with 5 nodes and 2 classes\nNode names: ['Source', 'Delay1', 'Queue1', 'Queue2', 'Sink']\nClass names: ['Class1', 'Class2']\n",
            "numerical_values": [
              5.0,
              2.0,
              1.0,
              1.0,
              2.0,
              1.0,
              2.0
            ]
          }
        }
      ],
      "execution_count": 3
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Aligned with JAR test scenarios for oqn_oneline# JAR tests: Fluid() only# Solve with Fluid solver (matches JAR)solver_fluid = FLD(model)avg_table_fluid = solver_fluid.avg_table()print(avg_table_fluid)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:23:10.194583Z",
          "start_time": "2025-07-30T22:23:08.853467Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:13:17.817444Z",
          "iopub.execute_input": "2026-01-02T14:13:17.817777Z",
          "shell.execute_reply": "2026-01-02T14:13:17.819478Z",
          "iopub.status.idle": "2026-01-02T14:13:17.819927Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Original JMT comparison commented out to align with JAR (Fluid only)# # solver_jmt = JMT(model)# avg_table_jmt = solver_jmt.avg_table()# print(avg_table_jmt)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:23:10.312961Z",
          "start_time": "2025-07-30T22:23:10.208869Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:13:17.821256Z",
          "iopub.execute_input": "2026-01-02T14:13:17.821421Z",
          "shell.execute_reply": "2026-01-02T14:13:17.822894Z",
          "iopub.status.idle": "2026-01-02T14:13:17.823267Z"
        }
      },
      "outputs": [],
      "execution_count": 5
    },
    "cell_5": {
      "cell_type": "code",
      "source": "# Performance analysis updated to use Fluid results only (JAR alignment)# Class-specific analysisfor class_name in ['Class1', 'Class2']:    class_metrics = avg_table_fluid[avg_table_fluid['JobClass'] == class_name]    print(f\"\\n{class_name}:\")        total_resp_time = class_metrics['RespT'].sum()    total_utilization = class_metrics['Util'].sum()    avg_throughput = class_metrics['Tput'].iloc[0] if len(class_metrics) > 0 else 0        print(f\"  Total response time: {total_resp_time:.4f}\")    print(f\"  Total utilization: {total_utilization:.4f}\")    print(f\"  Throughput: {avg_throughput:.6f}\")        # Per-station breakdown    for _, row in class_metrics.iterrows():        if row['RespT'] > 0:  # Only show stations with non-zero response time            print(f\"    {row['Station']}: RespT={row['RespT']:.4f}, Util={row['Util']:.4f}\")# System totalstotal_system_tput = avg_table_fluid['Tput'].sum()print(f\"\\nTotal system throughput: {total_system_tput:.6f}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:23:10.338020Z",
          "start_time": "2025-07-30T22:23:10.333622Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:13:17.824517Z",
          "iopub.execute_input": "2026-01-02T14:13:17.824695Z",
          "shell.execute_reply": "2026-01-02T14:13:17.826117Z",
          "iopub.status.idle": "2026-01-02T14:13:17.826427Z"
        }
      },
      "outputs": [],
      "execution_count": 6
    },
    "cell_6": {
      "cell_type": "code",
      "source": "# Little's Law verification updated to use Fluid results only (JAR alignment)for class_name in ['Class1', 'Class2']:    class_metrics = avg_table_fluid[avg_table_fluid['JobClass'] == class_name]    if len(class_metrics) > 0:        total_qlen = class_metrics['QLen'].sum()        total_resp_time = class_metrics['RespT'].sum()        throughput = class_metrics['Tput'].iloc[0]                # Little's Law: L = \u03bb * W        expected_qlen = throughput * total_resp_time                print(f\"\\n{class_name}:\")        print(f\"  Observed queue length: {total_qlen:.6f}\")        print(f\"  Expected (\u03bb*W): {expected_qlen:.6f}\")        print(f\"  Difference: {abs(total_qlen - expected_qlen):.8f}\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:23:10.397888Z",
          "start_time": "2025-07-30T22:23:10.394341Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-02T14:13:17.827235Z",
          "iopub.execute_input": "2026-01-02T14:13:17.827328Z",
          "shell.execute_reply": "2026-01-02T14:13:17.828627Z",
          "iopub.status.idle": "2026-01-02T14:13:17.828902Z"
        }
      },
      "outputs": [],
      "execution_count": 7
    }
  },
  "numerical_summary": {
    "cell_1": [
      0.02,
      0.04,
      10.0,
      5.0,
      5.0,
      9.0,
      91.0,
      92.0
    ],
    "cell_2": [
      5.0,
      2.0,
      1.0,
      1.0,
      2.0,
      1.0,
      2.0
    ],
    "cell_6": [
      1.0,
      2.0,
      0.0,
      0.0,
      0.6,
      0.6,
      0.8
    ]
  },
  "metadata": {
    "notebook_path": "openQN/oqn_oneline.ipynb",
    "source_dir": "examples/basic",
    "total_cells": 7,
    "code_cells": 7,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}