{
  "cell_content": {
    "cell_0": {
      "cell_type": "markdown",
      "source": "## Class-Dependent Service Analysis\n\nThis example demonstrates **class-dependent service allocation**, which is an advanced load-dependent modeling technique.\n\n### Concept:\n- **Class1 jobs**: Can utilize up to 2 servers based on their population at the queue\n- **Class2 jobs**: Always receive single-server treatment regardless of population\n- **Service allocation**: min(Class1_population, 2) servers allocated to Class1\n\n### Key Features:\n\n1. **Asymmetric Service**: Different job classes receive different levels of service capacity\n2. **Dynamic Allocation**: Server allocation changes based on specific class populations\n3. **Resource Prioritization**: Class1 gets priority access to multiple servers\n\n### Implementation Comparison:\n\n**MATLAB:**\n```matlab\nnode{2}.setClassDependence(@(ni) min(ni(1),c))\n```\n\n**Python:**\n```python\nnode2.set_class_dependence(lambda ni: min(ni[0, 0], c))\n```\n\n**Java:**\n```java\nnode2.setClassDependence(ni -> Math.min(ni.get(0, 0), c));\n```\n\n### Matrix Indexing Notes:\n- **MATLAB**: 1-indexed, so `ni(1)` is class 1, `ni(2)` is class 2\n- **Python/Java**: 0-indexed, so `ni[0, 0]` is class 1, `ni[0, 1]` is class 2\n- The Matrix has shape (1, R) where R is the number of job classes\n\n### Expected Behavior:\n- Class1 should have better performance (lower response times) due to multi-server access\n- Class2 performance is limited by single-server constraint\n- Total system performance depends on the interaction between both classes",
      "metadata": {},
      "outputs": [],
      "execution_count": null
    },
    "cell_1": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:48.423164Z",
          "iopub.execute_input": "2026-01-01T10:31:48.423251Z",
          "iopub.status.idle": "2026-01-01T10:31:48.897868Z",
          "shell.execute_reply": "2026-01-01T10:31:48.897552Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Model parameters\nN = 16  # number of jobs in Class1\nc = 2   # number of servers available for Class1\n\n# Create class-dependent model\ncdmodel = Network('cdmodel')\nnode1 = Delay(cdmodel, 'Delay')\nnode2 = Queue(cdmodel, 'Queue1', SchedStrategy.PS)\n\n# Create job classes\njobclass1 = ClosedClass(cdmodel, 'Class1', N, node1, 0)\njobclass2 = ClosedClass(cdmodel, 'Class2', N // 2, node1, 0)  # N/2 = 8 jobs\n\n# Set service times\nnode1.set_service(jobclass1, Exp.fit_mean(1.0))  # Class1: mean = 1.0\nnode1.set_service(jobclass2, Exp.fit_mean(2.0))  # Class2: mean = 2.0\nnode2.set_service(jobclass1, Exp.fit_mean(1.5))  # Class1: mean = 1.5\nnode2.set_service(jobclass2, Exp.fit_mean(2.5))  # Class2: mean = 2.5\n\n# Create routing matrix\nP = cdmodel.init_routing_matrix()\nP.set(jobclass1, jobclass1, node1, node2, 1.0)\nP.set(jobclass1, jobclass1, node2, node1, 1.0)\nP.set(jobclass2, jobclass2, node1, node2, 1.0)\nP.set(jobclass2, jobclass2, node2, node1, 1.0)\ncdmodel.link(P)",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:48.899105Z",
          "iopub.execute_input": "2026-01-01T10:31:48.899256Z",
          "iopub.status.idle": "2026-01-01T10:31:48.901707Z",
          "shell.execute_reply": "2026-01-01T10:31:48.901460Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Set class dependence function\n# In MATLAB: @(ni) min(ni(1),c) where ni(1) is Class1 population at the station\n# In Python: lambda ni: min(ni[0, 0], c) where ni[0, 0] is Class1 population\nprint(\"Setting class dependence...\")\n\nbeta = lambda ni: min(ni[0, 0], c)\nnode2.set_class_dependence(beta)\nprint(f\"Set class dependence: min(Class1_population, {c})\")",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:48.902519Z",
          "iopub.execute_input": "2026-01-01T10:31:48.902623Z",
          "shell.execute_reply": "2026-01-01T10:31:48.904244Z",
          "iopub.status.idle": "2026-01-01T10:31:48.904444Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "Setting class dependence...\nSet class dependence: min(Class1_population, 2)\n",
            "numerical_values": [
              1.0,
              2.0
            ]
          }
        }
      ],
      "execution_count": 3
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Solve with MVA using QD (queue decomposition) method\n# Note: QD method may not be available for this model in Python\ntry:\n    solver_mva_qd = MVA(cdmodel, method='qd')\n    cdAvgTableCD = solver_mva_qd.avg_table()\n    print(\"MVA QD Results:\")\n    print(cdAvgTableCD)\nexcept Exception as e:\n    print(f\"MVA QD solver not available: {e}\")\n    \n    # Try with exact MVA as fallback\n    print(\"\\nTrying MVA Exact method as fallback...\")\n    try:\n        solver_mva_exact = MVA(cdmodel)\n        cdAvgTableExact = solver_mva_exact.avg_table()\n        print(\"MVA Exact Results:\")\n        print(cdAvgTableExact)\n    except Exception as e2:\n        print(f\"MVA also failed: {e2}\")",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:48.905176Z",
          "iopub.execute_input": "2026-01-01T10:31:48.905253Z",
          "iopub.status.idle": "2026-01-01T10:31:48.948761Z",
          "shell.execute_reply": "2026-01-01T10:31:48.948505Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "MVA QD Results:\n  Station JobClass     QLen    Util    RespT   ResidT    ArvR    Tput\n0   Delay   Class1   1.3829  0.4451   3.1070   3.1070  0.4451  0.4451\n1   Delay   Class2   0.8157  0.2625   6.2140   6.2140  0.1313  0.1313\n2  Queue1   Class1  14.6171  0.6677  32.8395  32.8395  0.4451  0.4451\n3  Queue1   Class2   7.1843  0.3282  54.7325  54.7325  0.1313  0.1313\n",
            "numerical_values": [
              0.0,
              1.0,
              1.3829,
              0.4451,
              3.107,
              3.107,
              0.4451,
              0.4451,
              1.0,
              2.0,
              0.8157,
              0.2625,
              6.214,
              6.214,
              0.1313,
              0.1313,
              2.0,
              1.0,
              1.0,
              14.6171,
              0.6677,
              32.8395,
              32.8395,
              0.4451,
              0.4451,
              3.0,
              1.0,
              2.0,
              7.1843,
              0.3282,
              54.7325,
              54.7325,
              0.1313,
              0.1313
            ]
          }
        }
      ],
      "execution_count": 4
    },
    "cell_5": {
      "cell_type": "code",
      "source": "# Solve with CTMC (exact solution)try:    solver_ctmc = CTMC(cdmodel)    cdAvgTableCTMC = solver_ctmc.avg_table()    print(\"CTMC Results:\")    print(cdAvgTableCTMC)except Exception as e:    print(f\"CTMC solver not available or failed: {e}\")",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:48.949623Z",
          "iopub.execute_input": "2026-01-01T10:31:48.949715Z",
          "iopub.status.idle": "2026-01-01T10:31:48.951087Z",
          "shell.execute_reply": "2026-01-01T10:31:48.950886Z"
        }
      },
      "outputs": [],
      "execution_count": 5
    }
  },
  "numerical_summary": {
    "cell_3": [
      1.0,
      2.0
    ],
    "cell_4": [
      0.0,
      1.0,
      1.3829,
      0.4451,
      3.107,
      3.107,
      0.4451,
      0.4451,
      1.0,
      2.0,
      0.8157,
      0.2625,
      6.214,
      6.214,
      0.1313,
      0.1313,
      2.0,
      1.0,
      1.0,
      14.6171,
      0.6677,
      32.8395,
      32.8395,
      0.4451,
      0.4451,
      3.0,
      1.0,
      2.0,
      7.1843,
      0.3282,
      54.7325,
      54.7325,
      0.1313,
      0.1313,
      2.0,
      2.0
    ]
  },
  "metadata": {
    "notebook_path": "loadDependent/ld_class_dependence.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 6,
    "code_cells": 5,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}