{
  "cell_content": {
    "cell_0": {
      "cell_type": "markdown",
      "source": "# Load-Dependent Example 3: Multi-Class Load Dependence with PS Scheduling\n\nThis example demonstrates load-dependent queues with multiple job classes and PS (Processor Sharing) scheduling.\n\n**Features:**\n- Two closed classes: Class1 (4 jobs), Class2 (2 jobs)\n- Three stations: Delay + two PS queues with load dependence\n- Each queue has 3 servers with load dependence: min(total_jobs, servers)\n- Compares load-independent model vs load-dependent model\n- Demonstrates different solver methods: CTMC, NC, MVA",
      "metadata": {},
      "outputs": [],
      "execution_count": null
    },
    "cell_1": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T23:55:28.273620Z",
          "start_time": "2025-07-14T23:55:23.193199Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.158290Z",
          "iopub.execute_input": "2026-01-01T10:31:51.158378Z",
          "shell.execute_reply": "2026-01-01T10:31:51.626667Z",
          "iopub.status.idle": "2026-01-01T10:31:51.627009Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Model parameters\nN = 4  # number of jobs in Class1\nc = 3  # number of servers per queue\n\n# Create load-independent model for comparison\nmodel = Network('model')\nnode1 = Delay(model, 'Delay')\nnode2 = Queue(model, 'Queue1', SchedStrategy.PS)\nnode3 = Queue(model, 'Queue2', SchedStrategy.PS)\n\n# Create job classes\njobclass1 = ClosedClass(model, 'Class1', N, node1, 0)\njobclass2 = ClosedClass(model, 'Class2', N // 2, node1, 0)  # N/2 = 2 jobs\n\n# Set service times\nnode1.set_service(jobclass1, Exp.fit_mean(1.0))  # mean = 1.0\nnode1.set_service(jobclass2, Exp.fit_mean(2.0))  # mean = 2.0\n\nnode2.set_service(jobclass1, Exp.fit_mean(1.5))  # mean = 1.5\nnode2.set_service(jobclass2, Exp.fit_mean(2.5))  # mean = 2.5\nnode2.set_number_of_servers(c)\n\nnode3.set_service(jobclass1, Exp.fit_mean(3.5))  # mean = 3.5\nnode3.set_service(jobclass2, Exp.fit_mean(4.5))  # mean = 4.5\nnode3.set_number_of_servers(c)\n\n# Create routing matrix (serial routing for each class)\nP = model.init_routing_matrix()\nP.set(jobclass1, jobclass1, node1, node2, 1.0)\nP.set(jobclass1, jobclass1, node2, node3, 1.0)\nP.set(jobclass1, jobclass1, node3, node1, 1.0)\nP.set(jobclass2, jobclass2, node1, node2, 1.0)\nP.set(jobclass2, jobclass2, node2, node3, 1.0)\nP.set(jobclass2, jobclass2, node3, node1, 1.0)\nmodel.link(P)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T23:55:28.802840Z",
          "start_time": "2025-07-14T23:55:28.697839Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.628218Z",
          "iopub.execute_input": "2026-01-01T10:31:51.628354Z",
          "shell.execute_reply": "2026-01-01T10:31:51.630998Z",
          "iopub.status.idle": "2026-01-01T10:31:51.631223Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Solve load-independent model with MVA\nsolver_mva = MVA(model, method='exact')\nmsT = solver_mva.avg_table()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T23:55:29.651761Z",
          "start_time": "2025-07-14T23:55:29.116349Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.632045Z",
          "iopub.execute_input": "2026-01-01T10:31:51.632130Z",
          "iopub.status.idle": "2026-01-01T10:31:51.676018Z",
          "shell.execute_reply": "2026-01-01T10:31:51.675758Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stderr",
            "text": "/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/solvers_native/solver_mva.py:378: RuntimeWarning: invalid value encountered in cast\n  result = pfqn_mvams(lambda_arr, L, N, Z, mi=None, S=mi.astype(int))\n",
            "numerical_values": [
              378.0
            ]
          }
        }
      ],
      "execution_count": 3
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Create load-dependent model\nldmodel = Network('ldmodel')\nnode1 = Delay(ldmodel, 'Delay')\nnode2 = Queue(ldmodel, 'Queue1', SchedStrategy.PS)\nnode3 = Queue(ldmodel, 'Queue2', SchedStrategy.PS)\n\n# Create job classes\njobclass1 = ClosedClass(ldmodel, 'Class1', N, node1, 0)\njobclass2 = ClosedClass(ldmodel, 'Class2', N // 2, node1, 0)\n\n# Set service times (same as load-independent model)\nnode1.set_service(jobclass1, Exp.fit_mean(1.0))\nnode1.set_service(jobclass2, Exp.fit_mean(2.0))\n\nnode2.set_service(jobclass1, Exp.fit_mean(1.5))\nnode2.set_service(jobclass2, Exp.fit_mean(2.5))\n\nnode3.set_service(jobclass1, Exp.fit_mean(3.5))\nnode3.set_service(jobclass2, Exp.fit_mean(4.5))\n\n# Set load dependence: min(total_jobs, c) servers\ntotal_jobs = N + N // 2  # 4 + 2 = 6 total jobs\nalpha = np.minimum(np.arange(1, total_jobs + 1), c)  # min(1:6, 3) = [1,2,3,3,3,3]\nnode2.set_load_dependence(alpha)\nnode3.set_load_dependence(alpha)\n\n# Create routing matrix\nP = ldmodel.init_routing_matrix()\nP.set(jobclass1, jobclass1, node1, node2, 1.0)\nP.set(jobclass1, jobclass1, node2, node3, 1.0)\nP.set(jobclass1, jobclass1, node3, node1, 1.0)\nP.set(jobclass2, jobclass2, node1, node2, 1.0)\nP.set(jobclass2, jobclass2, node2, node3, 1.0)\nP.set(jobclass2, jobclass2, node3, node1, 1.0)\nldmodel.link(P)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T23:55:29.807320Z",
          "start_time": "2025-07-14T23:55:29.713371Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.676786Z",
          "iopub.execute_input": "2026-01-01T10:31:51.676880Z",
          "iopub.status.idle": "2026-01-01T10:31:51.679499Z",
          "shell.execute_reply": "2026-01-01T10:31:51.679293Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    },
    "cell_5": {
      "cell_type": "code",
      "source": "# Solve with CTMC (exact solution)\nsolver_ctmc = CTMC(ldmodel)\nlldAvgTableCTMC = solver_ctmc.avg_table()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T23:55:30.709193Z",
          "start_time": "2025-07-14T23:55:29.885325Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.680092Z",
          "iopub.execute_input": "2026-01-01T10:31:51.680170Z",
          "iopub.status.idle": "2026-01-01T10:31:51.687564Z",
          "shell.execute_reply": "2026-01-01T10:31:51.687360Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stderr",
            "text": "/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/api_native/solvers/ctmc/handler.py:518: RuntimeWarning: invalid value encountered in scalar multiply\n  TN[ist, k] = UN[ist, k] * c * mu\n",
            "numerical_values": [
              518.0
            ]
          }
        }
      ],
      "execution_count": 5
    },
    "cell_6": {
      "cell_type": "code",
      "source": "# Solve with NC (Normalizing Constant) - Exact method\nsolver_nc_exact = NC(ldmodel, method='exact')\nlldAvgTableNC = solver_nc_exact.avg_table()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-14T23:55:31.275101Z",
          "start_time": "2025-07-14T23:55:30.802504Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.688325Z",
          "iopub.execute_input": "2026-01-01T10:31:51.688402Z",
          "iopub.status.idle": "2026-01-01T10:31:51.691324Z",
          "shell.execute_reply": "2026-01-01T10:31:51.691092Z"
        }
      },
      "outputs": [],
      "execution_count": 6
    },
    "cell_7": {
      "cell_type": "code",
      "source": "# Solve with NC - Reduction heuristic (RD) method\nsolver_nc_rd = NC(ldmodel, method='rd')\nlldAvgTableRD = solver_nc_rd.avg_table()",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.692009Z",
          "iopub.execute_input": "2026-01-01T10:31:51.692083Z",
          "shell.execute_reply": "2026-01-01T10:31:51.695011Z",
          "iopub.status.idle": "2026-01-01T10:31:51.695262Z"
        }
      },
      "outputs": [],
      "execution_count": 7
    },
    "cell_8": {
      "cell_type": "code",
      "source": "# Solve with NC - NRP and NRL methods\nsolver_nc_nrp = NC(ldmodel, method='nrp')\nlldAvgTableNRP = solver_nc_nrp.avg_table()",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.695962Z",
          "iopub.execute_input": "2026-01-01T10:31:51.696039Z",
          "shell.execute_reply": "2026-01-01T10:31:51.700143Z",
          "iopub.status.idle": "2026-01-01T10:31:51.700326Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stderr",
            "text": "/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/api_native/pfqn/ncld.py:178: ComplexWarning: Casting complex values to real discards the imaginary part\n  L = np.atleast_2d(np.asarray(L, dtype=float))\n",
            "numerical_values": [
              178.0,
              2.0
            ]
          }
        }
      ],
      "execution_count": 8
    },
    "cell_9": {
      "cell_type": "code",
      "source": "\nsolver_nc_nrl = NC(ldmodel, method='nrl')\nlldAvgTableNRL = solver_nc_nrl.avg_table()",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.701089Z",
          "iopub.execute_input": "2026-01-01T10:31:51.701165Z",
          "shell.execute_reply": "2026-01-01T10:31:51.704525Z",
          "iopub.status.idle": "2026-01-01T10:31:51.704702Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stderr",
            "text": "/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/api_native/pfqn/ncld.py:178: ComplexWarning: Casting complex values to real discards the imaginary part\n  L = np.atleast_2d(np.asarray(L, dtype=float))\n",
            "numerical_values": [
              178.0,
              2.0
            ]
          }
        }
      ],
      "execution_count": 9
    },
    "cell_10": {
      "cell_type": "code",
      "source": "# Solve with MVA for load-dependent model\nsolver_mva_ld = MVA(ldmodel, method='exact')\nlldAvgTableMVALD = solver_mva_ld.avg_table()",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.705313Z",
          "iopub.execute_input": "2026-01-01T10:31:51.705387Z",
          "shell.execute_reply": "2026-01-01T10:31:51.708017Z",
          "iopub.status.idle": "2026-01-01T10:31:51.708239Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stderr",
            "text": "/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/solvers_native/solver_mva.py:378: RuntimeWarning: invalid value encountered in cast\n  result = pfqn_mvams(lambda_arr, L, N, Z, mi=None, S=mi.astype(int))\n",
            "numerical_values": [
              378.0
            ]
          }
        }
      ],
      "execution_count": 10
    },
    "cell_11": {
      "cell_type": "code",
      "source": "\nsolver_mva_qd = MVA(ldmodel, method='qd')\nlldAvgTableQD = solver_mva_qd.avg_table()",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:51.708911Z",
          "iopub.execute_input": "2026-01-01T10:31:51.708991Z",
          "iopub.status.idle": "2026-01-01T10:31:51.711778Z",
          "shell.execute_reply": "2026-01-01T10:31:51.711566Z"
        }
      },
      "outputs": [],
      "execution_count": 11
    },
    "cell_12": {
      "cell_type": "markdown",
      "source": "## Results Analysis\n\nThis example demonstrates the effect of load dependence on queue performance:\n\n1. **Load-Independent Model**: Each queue has a fixed number of servers (3) regardless of population\n2. **Load-Dependent Model**: Number of active servers depends on total population: min(population, 3)\n\nThe load dependence affects system performance by:\n- Limiting the effective service capacity when population is low\n- Providing full service capacity only when enough jobs are present\n- This creates more realistic modeling of servers that scale with demand\n\nDifferent solvers (CTMC, NC, MVA) provide various numerical methods for solving the same model, allowing comparison of accuracy and computational efficiency.",
      "metadata": {},
      "outputs": [],
      "execution_count": null
    }
  },
  "numerical_summary": {
    "cell_0": [
      3.0,
      1.0,
      4.0,
      2.0,
      2.0,
      3.0
    ],
    "cell_3": [
      378.0
    ],
    "cell_5": [
      518.0
    ],
    "cell_8": [
      178.0,
      2.0
    ],
    "cell_9": [
      178.0,
      2.0
    ],
    "cell_10": [
      378.0
    ],
    "cell_12": [
      1.0,
      3.0,
      2.0,
      3.0
    ]
  },
  "metadata": {
    "notebook_path": "loadDependent/ld_multiserver_ps.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 13,
    "code_cells": 11,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}