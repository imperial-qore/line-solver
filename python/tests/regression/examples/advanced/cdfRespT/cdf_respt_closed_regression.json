{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-12-30T05:33:45.579486400Z",
          "start_time": "2025-12-30T05:33:45.127505800Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:23.230342Z",
          "iopub.execute_input": "2026-01-01T10:31:23.230422Z",
          "shell.execute_reply": "2026-01-01T10:31:23.689229Z",
          "iopub.status.idle": "2026-01-01T10:31:23.689620Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# CDF Response Time Analysis Example 1\n# Demonstrates cumulative distribution function analysis for a closed network\n\nmodel = Network('model')\n\n# Create closed queueing network with Delay and Queue nodes\nnode = [None] * 2  # using 0-based indexing\nnode[0] = Delay(model, 'Delay')\nnode[1] = Queue(model, 'Queue2', SchedStrategy.PS)\n\n# Single closed class with 1 job starting at Delay node\njobclass = [None] * 1  # using 0-based indexing\njobclass[0] = ClosedClass(model, 'Class1', 1, node[0], 0)\n\n# Service processes - match MATLAB exactly\nservProc1 = Exp(1/0.1)  # rate = 1/0.1 = 10\nnode[0].set_service(jobclass[0], servProc1)\n\nservProc2 = Erlang.fit_mean_and_scv(1, 1/3)  # mean=1, SCV=1/3\nnode[1].set_service(jobclass[0], servProc2)\n\n# Routing matrix - circular routing between the two nodes\nP = model.init_routing_matrix()\nP.set(jobclass[0], jobclass[0], node[0], node[1], 1.0)\nP.set(jobclass[0], jobclass[0], node[1], node[0], 1.0)\nmodel.link(P)",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:23.690992Z",
          "iopub.execute_input": "2026-01-01T10:31:23.691157Z",
          "shell.execute_reply": "2026-01-01T10:31:23.693283Z",
          "iopub.status.idle": "2026-01-01T10:31:23.693482Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Solve with JMT solver - aligned with JAR test scenario\nsolver = JMT(model, seed=23000, samples=10000)  # Aligned with JAR test: seed=23000, samples=10000\nFC = solver.cdf_respt()\n\nAvgRespTfromCDFSim = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nPowerMoment2_R = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nVariance_R = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nSqCoeffOfVariationRespTfromCDFSim = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\n\nfor i in range(model.get_number_of_stations()):\n    for c in range(model.get_number_of_classes()):\n        if FC[i][c] is not None and len(FC[i][c]) > 1:\n            # Calculate mean from CDF\n            diffs = np.diff(FC[i][c][:, 0])\n            values = FC[i][c][1:, 1]\n            AvgRespTfromCDFSim[i, c] = np.sum(diffs * values)\n            \n            # Calculate second moment and variance\n            PowerMoment2_R[i, c] = np.sum(diffs * (values ** 2))\n            Variance_R[i, c] = PowerMoment2_R[i, c] - AvgRespTfromCDFSim[i, c] ** 2\n            SqCoeffOfVariationRespTfromCDFSim[i, c] = Variance_R[i, c] / (AvgRespTfromCDFSim[i, c] ** 2)\n\n# Solve with Fluid solver - aligned with JAR test scenario (default options)\nsolver = FLD(model)  # Using default options like JAR test\nFC = solver.cdf_respt()\n\nAvgRespTfromCDFFluid = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nSqCoeffOfVariationRespTfromCDFFluid = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\n\nfor i in range(model.get_number_of_stations()):\n    for c in range(model.get_number_of_classes()):\n        if FC[i][c] is not None and len(FC[i][c]) > 1:\n            # Calculate mean from CDF  \n            diffs = np.diff(FC[i][c][:, 0])\n            values = FC[i][c][1:, 1]\n            AvgRespTfromCDFFluid[i, c] = np.sum(diffs * values)\n            \n            # Calculate second moment and variance\n            PowerMoment2_R_fluid = np.sum(diffs * (values ** 2))\n            Variance_R_fluid = PowerMoment2_R_fluid - AvgRespTfromCDFFluid[i, c] ** 2\n            SqCoeffOfVariationRespTfromCDFFluid[i, c] = Variance_R_fluid / (AvgRespTfromCDFFluid[i, c] ** 2)\n\n# Theoretical values from service processes\nAvgRespTfromTheory = np.array([servProc1.get_mean(), servProc2.get_mean()])\nSqCoeffOfVariationRespTfromTheory = np.array([servProc1.get_scv(), servProc2.get_scv()])\n\nprint('AvgRespTfromTheory =')\nprint(AvgRespTfromTheory)\nprint('AvgRespTfromCDFSim =')\nprint(AvgRespTfromCDFSim)\nprint('AvgRespTfromCDFFluid =')\nprint(AvgRespTfromCDFFluid)\nprint('SqCoeffOfVariationRespTfromTheory =')\nprint(SqCoeffOfVariationRespTfromTheory)\nprint('SqCoeffOfVariationRespTfromCDFSim =')\nprint(SqCoeffOfVariationRespTfromCDFSim)\nprint('SqCoeffOfVariationRespTfromCDFFluid =')\nprint(SqCoeffOfVariationRespTfromCDFFluid)",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:23.694255Z",
          "iopub.execute_input": "2026-01-01T10:31:23.694336Z",
          "iopub.status.idle": "2026-01-01T10:31:24.022996Z",
          "shell.execute_reply": "2026-01-01T10:31:24.022785Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stderr",
            "text": "/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/solvers.py:1356: UserWarning: SolverJMT native does not currently support CDF extraction. Returning empty results. Use SolverFluid (FLD) for CDF analysis.\n  warnings.warn(\n",
            "numerical_values": [
              1356.0
            ]
          }
        },
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "AvgRespTfromTheory =\n[0.1 1. ]\nAvgRespTfromCDFSim =\n[[0.]\n [0.]]\nAvgRespTfromCDFFluid =\n[[2.68417623]\n [2.68417623]]\nSqCoeffOfVariationRespTfromTheory =\n[1.         0.33333333]\nSqCoeffOfVariationRespTfromCDFSim =\n[[0.]\n [0.]]\nSqCoeffOfVariationRespTfromCDFFluid =\n[[0.31756257]\n [0.31756257]]\n",
            "numerical_values": [
              0.1,
              1.0,
              0.0,
              0.0,
              2.68417623,
              2.68417623,
              1.0,
              0.33333333,
              0.0,
              0.0,
              0.31756257,
              0.31756257
            ]
          }
        },
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stderr",
            "text": "/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/solvers_native/solver_fld_native/methods/passage_time.py:82: UserWarning: Passage time analysis on multi-station network (M=2). Using station 0 only.\n  warnings.warn(f\"Passage time analysis on multi-station network (M={self.sn.nstations}). \"\n/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/solvers_native/solver_fld_native/methods/passage_time.py:82: UserWarning: Passage time analysis on multi-station network (M=2). Using station 1 only.\n  warnings.warn(f\"Passage time analysis on multi-station network (M={self.sn.nstations}). \"\n",
            "numerical_values": [
              82.0,
              2.0,
              0.0,
              82.0,
              2.0,
              1.0
            ]
          }
        }
      ],
      "execution_count": 3
    }
  },
  "numerical_summary": {
    "cell_2": [
      1356.0,
      0.1,
      1.0,
      0.0,
      0.0,
      2.68417623,
      2.68417623,
      1.0,
      0.33333333,
      0.0,
      0.0,
      0.31756257,
      0.31756257,
      82.0,
      2.0,
      0.0,
      82.0,
      2.0,
      1.0
    ]
  },
  "metadata": {
    "notebook_path": "cdfRespT/cdf_respt_closed.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 3,
    "code_cells": 3,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}