{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:33.173045Z",
          "start_time": "2025-09-10T15:33:31.891772Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:25.025631Z",
          "iopub.execute_input": "2026-01-01T10:31:25.025717Z",
          "iopub.status.idle": "2026-01-01T10:31:25.493958Z",
          "shell.execute_reply": "2026-01-01T10:31:25.493664Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# CDF Response Time Analysis Example 2\n# Demonstrates class switching in a closed network with 3 classes\n\nmodel = Network('model')\n\n# Create closed queueing network with Delay and Queue nodes\nnode = [None] * 2  # using 0-based indexing\nnode[0] = Delay(model, 'Delay')\nnode[1] = Queue(model, 'Queue2', SchedStrategy.PS)\n\n# Three closed classes - only Class1 has initial population\njobclass = [None] * 3  # using 0-based indexing\njobclass[0] = ClosedClass(model, 'Class1', 1, node[0], 0)\njobclass[1] = ClosedClass(model, 'Class2', 0, node[0], 0)\njobclass[2] = ClosedClass(model, 'Class3', 0, node[0], 0)\n\n# Class1 doesn't complete (stays in the system for class switching)\njobclass[0].completes = False\n\n# Service processes at Delay node\nnode[0].set_service(jobclass[0], Exp(1/1))  # rate = 1\nnode[0].set_service(jobclass[1], Exp(1/1))  # rate = 1\nnode[0].set_service(jobclass[2], Exp(1/1))  # rate = 1\n\n# Service processes at Queue node\nnode[1].set_service(jobclass[0], Exp(1/1))      # rate = 1\nnode[1].set_service(jobclass[1], Erlang(1/2, 2)) # Erlang with rate=1/2, order=2\nnode[1].set_service(jobclass[2], Exp(1/0.01))   # rate = 100\n\n# Complex routing matrix with class switching\nP = model.init_routing_matrix()\n\n# Class 1 to Class 1: Delay->Queue2\nP.set(jobclass[0], jobclass[0], node[0], node[1], 1.0)\n\n# Class 1 to Class 2: Queue2->Delay (class switch)\nP.set(jobclass[0], jobclass[1], node[1], node[0], 1.0)\n\n# Class 2 to Class 1: Delay->Queue2 (class switch back)\nP.set(jobclass[1], jobclass[0], node[1], node[0], 1.0)\n\n# Class 2 to Class 2: Delay->Queue2\nP.set(jobclass[1], jobclass[1], node[0], node[1], 1.0)\n\n# Class 3 circulates within itself\nP.set(jobclass[2], jobclass[2], node[0], node[1], 1.0)\nP.set(jobclass[2], jobclass[2], node[1], node[0], 1.0)\n\nmodel.link(P)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:33.205964Z",
          "start_time": "2025-09-10T15:33:33.177729Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:25.495028Z",
          "iopub.execute_input": "2026-01-01T10:31:25.495181Z",
          "iopub.status.idle": "2026-01-01T10:31:25.498177Z",
          "shell.execute_reply": "2026-01-01T10:31:25.497949Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# NOTE: The JAR test shows that JMT getCdfRespT is not implemented for multi-class models\n# So we only implement the Fluid solver scenario that works\n\n# Solve with Fluid solver - aligned with JAR test scenario\nsolver = FLD(model, method='statedep', iter_max=100)\nAvgRespT = solver.avg_respt()\nprint('AvgRespT =')\nprint(AvgRespT)\n\n# Get CDF of response times\nFC = solver.cdf_respt()\n\n# Calculate statistics from CDF\nAvgRespTfromCDF = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nPowerMoment2_R = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nVariance_R = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\nSqCoeffOfVariationRespTfromCDF = np.zeros((model.get_number_of_stations(), model.get_number_of_classes()))\n\nfor i in range(model.get_number_of_stations()):\n    for c in range(model.get_number_of_classes()):\n        if FC[i][c] is not None and len(FC[i][c]) > 1:\n            # Calculate mean from CDF\n            diffs = np.diff(FC[i][c][:, 0])\n            values = FC[i][c][1:, 1]\n            AvgRespTfromCDF[i, c] = np.sum(diffs * values)\n            \n            # Calculate second moment and variance\n            PowerMoment2_R[i, c] = np.sum(diffs * (values ** 2))\n            Variance_R[i, c] = PowerMoment2_R[i, c] - AvgRespTfromCDF[i, c] ** 2\n            \n            # Avoid division by zero (like MATLAB's implicit handling)\n            if AvgRespTfromCDF[i, c] != 0:\n                SqCoeffOfVariationRespTfromCDF[i, c] = Variance_R[i, c] / (AvgRespTfromCDF[i, c] ** 2)\n            else:\n                SqCoeffOfVariationRespTfromCDF[i, c] = np.nan\n\nprint('AvgRespTfromCDF =')\nprint(AvgRespTfromCDF)\nprint('SqCoeffOfVariationRespTfromCDF =')\nprint(SqCoeffOfVariationRespTfromCDF)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-09-10T15:33:36.620819Z",
          "start_time": "2025-09-10T15:33:33.240050Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:25.498914Z",
          "iopub.execute_input": "2026-01-01T10:31:25.499002Z",
          "shell.execute_reply": "2026-01-01T10:31:25.550714Z",
          "iopub.status.idle": "2026-01-01T10:31:25.551014Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "AvgRespT =\nNone\nAvgRespTfromCDF =\n[[2.68417623 2.68417623 2.68417623]\n [2.68417623 2.68417623 2.68417623]]\nSqCoeffOfVariationRespTfromCDF =\n[[0.31756257 0.31756257 0.31756257]\n [0.31756257 0.31756257 0.31756257]]\n",
            "numerical_values": [
              2.68417623,
              2.68417623,
              2.68417623,
              2.68417623,
              2.68417623,
              2.68417623,
              0.31756257,
              0.31756257,
              0.31756257,
              0.31756257,
              0.31756257,
              0.31756257
            ]
          }
        },
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stderr",
            "text": "/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/solvers_native/solver_fld_native/methods/passage_time.py:82: UserWarning: Passage time analysis on multi-station network (M=2). Using station 0 only.\n  warnings.warn(f\"Passage time analysis on multi-station network (M={self.sn.nstations}). \"\n/home/gcasale/Dropbox/code/line-dev.git/python/line_solver/solvers_native/solver_fld_native/methods/passage_time.py:82: UserWarning: Passage time analysis on multi-station network (M=2). Using station 1 only.\n  warnings.warn(f\"Passage time analysis on multi-station network (M={self.sn.nstations}). \"\n",
            "numerical_values": [
              82.0,
              2.0,
              0.0,
              82.0,
              2.0,
              1.0
            ]
          }
        }
      ],
      "execution_count": 3
    }
  },
  "numerical_summary": {
    "cell_2": [
      2.68417623,
      2.68417623,
      2.68417623,
      2.68417623,
      2.68417623,
      2.68417623,
      0.31756257,
      0.31756257,
      0.31756257,
      0.31756257,
      0.31756257,
      0.31756257,
      82.0,
      2.0,
      0.0,
      82.0,
      2.0,
      1.0
    ]
  },
  "metadata": {
    "notebook_path": "cdfRespT/cdf_respt_closed_threeclasses.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 3,
    "code_cells": 3,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}