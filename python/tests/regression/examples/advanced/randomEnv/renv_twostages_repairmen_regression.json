{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "collapsed": false,
        "ExecuteTime": {
          "end_time": "2025-07-15T22:53:57.966996Z",
          "start_time": "2025-07-15T22:53:53.073175Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:58.738554Z",
          "iopub.execute_input": "2026-01-01T10:31:58.738637Z",
          "shell.execute_reply": "2026-01-01T10:31:59.222744Z",
          "iopub.status.idle": "2026-01-01T10:31:59.223106Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "N = 1\nM = 2\nE = 2\nenvModel = Environment('MyEnv', E)\nenvName = ['Stage1', 'Stage2']\nenvType = ['UP', 'DOWN']\n\nrate = np.array([[2,1],[1,2]])",
      "metadata": {
        "collapsed": false,
        "ExecuteTime": {
          "end_time": "2025-07-15T22:53:58.259511Z",
          "start_time": "2025-07-15T22:53:58.212950Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:59.224380Z",
          "iopub.execute_input": "2026-01-01T10:31:59.224514Z",
          "shell.execute_reply": "2026-01-01T10:31:59.226343Z",
          "iopub.status.idle": "2026-01-01T10:31:59.226617Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "def renv_genqn(rate, N):\n    # sn1\n    qnet = Network('qn1')\n    \n    node = np.empty(2, dtype=object)\n    node[0] = Delay(qnet, 'Queue1')\n    node[1] = Queue(qnet, 'Queue2', SchedStrategy.PS)\n\n    jobclass = np.empty(1, dtype=object)\n    jobclass[0] = ClosedClass(qnet, 'Class1', N, node[0], 0)\n    \n    node[0].set_service(jobclass[0], Exp(rate[0]))\n    node[1].set_service(jobclass[0], Exp(rate[1]))\n    \n    P = qnet.init_routing_matrix()\n    P.set(jobclass[0],jobclass[0], [[0,1],[1,0]])\n    qnet.link(P)\n    return qnet",
      "metadata": {
        "collapsed": false,
        "ExecuteTime": {
          "end_time": "2025-07-15T22:53:58.445547Z",
          "start_time": "2025-07-15T22:53:58.413920Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:59.227557Z",
          "iopub.execute_input": "2026-01-01T10:31:59.227637Z",
          "shell.execute_reply": "2026-01-01T10:31:59.229254Z",
          "iopub.status.idle": "2026-01-01T10:31:59.229476Z"
        }
      },
      "outputs": [],
      "execution_count": 3
    },
    "cell_3": {
      "cell_type": "code",
      "source": "envSubModel = [renv_genqn(rate[:,0],N), renv_genqn(rate[:,1],N)]\n\nfor e in range(E):\n    envModel.add_stage(e, envName[e], envType[e], envSubModel[e])\n \nenvRates = [[0,1], [0.5,0.5]]\nfor e in range(E):\n    for h in range(E):\n        if envRates[e][h]>0.0:\n            envModel.add_transition(e, h, Exp(envRates[e][h]))",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T22:53:58.674610Z",
          "start_time": "2025-07-15T22:53:58.555207Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:59.230340Z",
          "iopub.execute_input": "2026-01-01T10:31:59.230423Z",
          "shell.execute_reply": "2026-01-01T10:31:59.231986Z",
          "iopub.status.idle": "2026-01-01T10:31:59.232189Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Display stage table\nprint(\"Stage Table:\")\nenvModel.stage_table()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T22:54:08.006893Z",
          "start_time": "2025-07-15T22:54:07.841024Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:59.232817Z",
          "iopub.execute_input": "2026-01-01T10:31:59.232893Z",
          "shell.execute_reply": "2026-01-01T10:31:59.237745Z",
          "iopub.status.idle": "2026-01-01T10:31:59.237920Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "Stage Table:\n Stage   Name Type Model\n     0 Stage1   UP   qn1\n     1 Stage2 DOWN   qn1\n",
            "numerical_values": [
              0.0,
              1.0,
              1.0,
              1.0,
              2.0,
              1.0
            ]
          }
        },
        {
          "output_type": "execute_result",
          "execution_count": 5,
          "metadata": {},
          "content": {
            "text/plain": "   Stage    Name  Type Model\n0      0  Stage1    UP   qn1\n1      1  Stage2  DOWN   qn1",
            "numerical_values": [
              0.0,
              0.0,
              1.0,
              1.0,
              1.0,
              1.0,
              2.0,
              1.0
            ],
            "text/html": "<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Stage</th>\n      <th>Name</th>\n      <th>Type</th>\n      <th>Model</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>Stage1</td>\n      <td>UP</td>\n      <td>qn1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>Stage2</td>\n      <td>DOWN</td>\n      <td>qn1</td>\n    </tr>\n  </tbody>\n</table>\n</div>"
          }
        }
      ],
      "execution_count": 5
    },
    "cell_5": {
      "cell_type": "code",
      "source": "# Configure solver options  \nfrom line_solver import SolverType\noptions = SolverOptions(SolverType.ENV.value)\noptions.timespan = [0, float('inf')]\noptions.iter_max = 100\noptions.iter_tol = 0.01\noptions.method = 'default'\noptions.verbose = True\n\n# Configure fluid solver options\nsfoptions = SolverOptions(SolverType.FLUID.value)\nsfoptions.timespan = [0, 1e3]\nsfoptions.verbose = False\n\n# Create solvers for each submodel\nsolvers = np.empty(E, dtype=object)\nfor e in range(E):\n    solvers[e] = FLD(envSubModel[e], sfoptions)\n\n# Create environment solver\nenvSolver = ENV(envModel, solvers, options)\n\n# Get results\ntry:\n    QN, UN, TN = envSolver.avg()\n    print(\"Average queue lengths (QN):\", QN)\n    print(\"Average utilizations (UN):\", UN)\n    print(\"Average throughputs (TN):\", TN)\n    \n    AvgTable = envSolver.avg_table()\n    print(\"\\nAverage Table:\")\n    print(AvgTable)\n    \nexcept Exception as e:\n    print(f\"Error during solving: {e}\")\n    print(\"Note: Environment solver features may not be fully implemented\")",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T22:55:23.614348Z",
          "start_time": "2025-07-15T22:55:23.499462Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:59.238746Z",
          "iopub.execute_input": "2026-01-01T10:31:59.238823Z",
          "shell.execute_reply": "2026-01-01T10:31:59.282555Z",
          "iopub.status.idle": "2026-01-01T10:31:59.282869Z"
        }
      },
      "outputs": [
        {
          "output_type": "stream",
          "execution_count": null,
          "metadata": {},
          "content": {
            "stream_name": "stdout",
            "text": "Error during solving: unsupported operand type(s) for *: 'float' and 'NoneType'\nNote: Environment solver features may not be fully implemented\n"
          }
        }
      ],
      "execution_count": 6
    },
    "cell_6": {
      "cell_type": "markdown",
      "source": "## Alternative: CTMC Solver (Commented)\nThe MATLAB version also shows an alternative using CTMC, which is commented out in the original.",
      "metadata": {},
      "outputs": [],
      "execution_count": null
    },
    "cell_7": {
      "cell_type": "code",
      "source": "# Alternative solver using CTMC (commented out as in MATLAB version)\n# scoptions = SolverOptions()\n# scoptions.timespan = [0, 1e3]\n# scoptions.verbose = False\n# envSolver = ENV(envModel, lambda model: CTMC(model, scoptions), options)\n# QNc, UNc, TNc = envSolver.avg()\n# AvgTableC = envSolver.avg_table()\n# print(\"CTMC Results:\")\n# print(\"Average Table (CTMC):\", AvgTableC)",
      "metadata": {
        "execution": {
          "iopub.status.busy": "2026-01-01T10:31:59.283687Z",
          "iopub.execute_input": "2026-01-01T10:31:59.283779Z",
          "shell.execute_reply": "2026-01-01T10:31:59.284956Z",
          "iopub.status.idle": "2026-01-01T10:31:59.285205Z"
        }
      },
      "outputs": [],
      "execution_count": 7
    }
  },
  "numerical_summary": {
    "cell_1": [
      1.0,
      2.0,
      2.0,
      1.0,
      2.0,
      2.0,
      1.0,
      1.0,
      2.0
    ],
    "cell_3": [
      0.0,
      1.0,
      0.0,
      1.0,
      0.5,
      0.5,
      0.0
    ],
    "cell_4": [
      0.0,
      1.0,
      1.0,
      1.0,
      2.0,
      1.0,
      0.0,
      0.0,
      1.0,
      1.0,
      1.0,
      1.0,
      2.0,
      1.0
    ],
    "cell_5": [
      0.0,
      100.0,
      0.01,
      0.0,
      1000.0
    ],
    "cell_7": [
      0.0,
      1000.0
    ]
  },
  "metadata": {
    "notebook_path": "randomEnv/renv_twostages_repairmen.ipynb",
    "source_dir": "examples/advanced",
    "total_cells": 8,
    "code_cells": 7,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}