{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:16:27.240847Z",
          "start_time": "2025-07-30T22:16:26.389571Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:32:18.787191Z",
          "iopub.execute_input": "2026-01-03T15:32:18.787393Z",
          "shell.execute_reply": "2026-01-03T15:32:19.673666Z",
          "iopub.status.idle": "2026-01-03T15:32:19.674552Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "model = Network('model')\n\n# Nodes\ndelay = Delay(model, 'Delay')\nfork1 = Fork(model, 'Fork1')\nfork1.set_tasks_per_link(1)\nfork11 = Fork(model, 'Fork1_1')\nfork11.set_tasks_per_link(2)\njoin1 = Join(model, 'Join1', fork1)\njoin11 = Join(model, 'Join1_1', fork11)\nqueue1 = Queue(model, 'Queue1', SchedStrategy.PS)\nqueue2 = Queue(model, 'Queue2', SchedStrategy.PS)\n\n# Classes\njobclass1 = ClosedClass(model, 'class1', 5, delay, 0)\njobclass2 = ClosedClass(model, 'class2', 2, delay, 0)\n\n# Service times\ndelay.set_service(jobclass1, Exp(0.25))\nqueue1.set_service(jobclass1, Exp(1.0))\nqueue2.set_service(jobclass1, Exp(0.75))\n\ndelay.set_service(jobclass2, Exp(0.25))\nqueue1.set_service(jobclass2, Exp(2.0))\nqueue2.set_service(jobclass2, Exp(2.0))",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:16:27.340675Z",
          "start_time": "2025-07-30T22:16:27.315548Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:32:19.676131Z",
          "iopub.execute_input": "2026-01-03T15:32:19.676502Z",
          "shell.execute_reply": "2026-01-03T15:32:19.680675Z",
          "iopub.status.idle": "2026-01-03T15:32:19.681338Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Routing\nP = model.init_routing_matrix()\n\n# Class 1 routing\nP.set(jobclass1, jobclass1, delay, fork1, 1.0)\nP.set(jobclass1, jobclass1, fork1, queue1, 1.0)\nP.set(jobclass1, jobclass1, fork1, queue2, 1.0)\nP.set(jobclass1, jobclass1, queue1, join1, 1.0)\nP.set(jobclass1, jobclass1, queue2, join1, 1.0)\nP.set(jobclass1, jobclass1, join1, delay, 1.0)\n\n# Class 2 routing\nP.set(jobclass2, jobclass2, delay, fork11, 1.0)\nP.set(jobclass2, jobclass2, fork11, fork1, 1.0)\nP.set(jobclass2, jobclass2, fork1, queue1, 1.0)\nP.set(jobclass2, jobclass2, fork1, queue2, 1.0)\nP.set(jobclass2, jobclass2, queue1, join1, 1.0)\nP.set(jobclass2, jobclass2, queue2, join1, 1.0)\nP.set(jobclass2, jobclass2, join1, join11, 1.0)\nP.set(jobclass2, jobclass2, join11, delay, 1.0)\n\nmodel.link(P)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:16:27.365691Z",
          "start_time": "2025-07-30T22:16:27.355673Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:32:19.683428Z",
          "iopub.execute_input": "2026-01-03T15:32:19.683674Z",
          "iopub.status.idle": "2026-01-03T15:32:19.688826Z",
          "shell.execute_reply": "2026-01-03T15:32:19.688152Z"
        }
      },
      "outputs": [],
      "execution_count": 3
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Solve with different solverssolver = []# JMT solverjmt_options = JMT.default_options()jmt_options.seed = 23000solver.append(JMT(model, jmt_options))# MVA solversolver.append(MVA(model))# Get average tablesAvgTable = []for s in solver:    print(f'\\nSOLVER: {s.get_name()}')    avg_table = s.avg_table()    AvgTable.append(avg_table)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-30T22:16:29.655643Z",
          "start_time": "2025-07-30T22:16:27.408594Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:32:19.690749Z",
          "iopub.execute_input": "2026-01-03T15:32:19.690976Z",
          "shell.execute_reply": "2026-01-03T15:32:19.693135Z",
          "iopub.status.idle": "2026-01-03T15:32:19.693787Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    }
  },
  "numerical_summary": {
    "cell_3": [
      23000.0
    ]
  },
  "metadata": {
    "notebook_path": "forkJoin/fj_basic_nesting.ipynb",
    "source_dir": "examples/basic",
    "total_cells": 4,
    "code_cells": 4,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}