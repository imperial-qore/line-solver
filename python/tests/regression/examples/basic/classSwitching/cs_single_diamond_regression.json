{
  "cell_content": {
    "cell_0": {
      "cell_type": "code",
      "source": "from line_solver import *\nimport numpy as np\nGlobalConstants.set_verbose(VerboseLevel.STD)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T01:25:20.657111Z",
          "start_time": "2025-07-15T01:25:20.637671Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:31:29.242046Z",
          "iopub.execute_input": "2026-01-03T15:31:29.242132Z",
          "shell.execute_reply": "2026-01-03T15:31:29.824486Z",
          "iopub.status.idle": "2026-01-03T15:31:29.824957Z"
        }
      },
      "outputs": [],
      "execution_count": 1
    },
    "cell_1": {
      "cell_type": "code",
      "source": "# Class switching example 3\n# Example of class switching controlled by a reducible Markov chain\nmodel = Network('mm1cs')",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T01:25:20.779088Z",
          "start_time": "2025-07-15T01:25:20.769042Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:31:29.826212Z",
          "iopub.execute_input": "2026-01-03T15:31:29.826374Z",
          "shell.execute_reply": "2026-01-03T15:31:29.827575Z",
          "iopub.status.idle": "2026-01-03T15:31:29.827912Z"
        }
      },
      "outputs": [],
      "execution_count": 2
    },
    "cell_2": {
      "cell_type": "code",
      "source": "# Block 1: nodes\nnode = np.empty(3, dtype=object)\nnode[0] = Delay(model, 'Queue 0')\nnode[1] = Delay(model, 'Queue 1')\nnode[2] = Delay(model, 'Queue 2')\n\n# Block 2: classes\njobclass = np.empty(3, dtype=object)\njobclass[0] = ClosedClass(model, 'Class1', 1, node[0])\njobclass[1] = ClosedClass(model, 'Class2', 0, node[0])\njobclass[2] = ClosedClass(model, 'Class3', 0, node[0])",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T01:25:20.896259Z",
          "start_time": "2025-07-15T01:25:20.881654Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:31:29.828588Z",
          "iopub.execute_input": "2026-01-03T15:31:29.828703Z",
          "shell.execute_reply": "2026-01-03T15:31:29.830708Z",
          "iopub.status.idle": "2026-01-03T15:31:29.831007Z"
        }
      },
      "outputs": [],
      "execution_count": 3
    },
    "cell_3": {
      "cell_type": "code",
      "source": "# Service configurations\nnode[0].set_service(jobclass[0], Exp.fit_mean(1.000000))  # (Queue 0,Class1)\nnode[1].set_service(jobclass[1], Exp.fit_mean(2.000000))  # (Queue 1,Class2)\nnode[2].set_service(jobclass[2], Exp.fit_mean(3.000000))  # (Queue 2,Class3)",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T01:25:21.026333Z",
          "start_time": "2025-07-15T01:25:21.002189Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:31:29.832018Z",
          "iopub.execute_input": "2026-01-03T15:31:29.832130Z",
          "shell.execute_reply": "2026-01-03T15:31:29.833587Z",
          "iopub.status.idle": "2026-01-03T15:31:29.834012Z"
        }
      },
      "outputs": [],
      "execution_count": 4
    },
    "cell_4": {
      "cell_type": "code",
      "source": "# Routing matrix with class switching\nP = model.init_routing_matrix()  # initialize routing matrix\nP.set(jobclass[0], jobclass[0], node[0], node[0], 0.2)\nP.set(jobclass[0], jobclass[1], node[0], node[1], 0.3)\nP.set(jobclass[0], jobclass[2], node[0], node[2], 0.5)\nP.set(jobclass[1], jobclass[0], node[1], node[0], 1.0)\nP.set(jobclass[2], jobclass[0], node[2], node[0], 1.0)\nmodel.link(P)\n# model.printRoutingMatrix()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T01:25:21.199133Z",
          "start_time": "2025-07-15T01:25:21.154599Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:31:29.835215Z",
          "iopub.execute_input": "2026-01-03T15:31:29.835364Z",
          "shell.execute_reply": "2026-01-03T15:31:29.837779Z",
          "iopub.status.idle": "2026-01-03T15:31:29.838155Z"
        }
      },
      "outputs": [],
      "execution_count": 5
    },
    "cell_5": {
      "cell_type": "code",
      "source": "# Solve\nsolver = MVA(model)\nAvgTable = solver.avg_chain_table()",
      "metadata": {
        "ExecuteTime": {
          "end_time": "2025-07-15T01:25:21.647263Z",
          "start_time": "2025-07-15T01:25:21.531105Z"
        },
        "execution": {
          "iopub.status.busy": "2026-01-03T15:31:29.839105Z",
          "iopub.execute_input": "2026-01-03T15:31:29.839224Z",
          "shell.execute_reply": "2026-01-03T15:31:29.847560Z",
          "iopub.status.idle": "2026-01-03T15:31:29.847997Z"
        }
      },
      "outputs": [],
      "execution_count": 6
    }
  },
  "numerical_summary": {
    "cell_1": [
      3.0,
      1.0
    ]
  },
  "metadata": {
    "notebook_path": "classSwitching/cs_single_diamond.ipynb",
    "source_dir": "examples/basic",
    "total_cells": 6,
    "code_cells": 6,
    "generation_info": {
      "script_version": "2.0",
      "extraction_method": "comprehensive"
    }
  }
}